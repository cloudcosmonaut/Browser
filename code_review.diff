diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 00000000..aabe9afd
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,71 @@
+cmake_minimum_required (VERSION 3.16.0)
+
+option(DOXYGEN "Build Doxygen documentation" ON)
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")
+
+include(GitVersion)
+
+project(libreweb-browser
+  VERSION ${GIT_TAG_VERSION}
+  DESCRIPTION "LibreWeb Browser - Decentralized Web-Browser"
+  LANGUAGES C CXX)
+
+message(STATUS "CMAKE_BUILD_TYPE: ${CMAKE_BUILD_TYPE}")
+message(STATUS "PROJECT_VERSION: ${PROJECT_VERSION}")
+
+# Build docs using Doxygen
+if(DOXYGEN)
+  include(Doxygen)
+endif()
+
+# Production build, let's include the CPack settings
+if("${CMAKE_BUILD_TYPE}" STREQUAL "Release")
+  include(Packaging)
+endif()
+
+set(CMAKE_C_STANDARD 99)
+set(CMAKE_C_STANDARD_REQUIRED YES)
+set(CMAKE_C_EXTENSIONS NO)
+
+set(CMAKE_CXX_STANDARD 20)
+set(CMAKE_CXX_STANDARD_REQUIRED ON)
+if(NOT CYGWIN)
+  set(CMAKE_CXX_EXTENSIONS OFF)
+endif()
+
+if(WIN32)
+  set(WINDOWS_FLAGS -mwindows)
+endif()
+
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Werror")
+set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG}  -Wall")
+set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -O3 -DNDEBUG")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Werror")
+set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g")
+set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} ${WINDOWS_FLAGS} -O3 -DNDEBUG")
+
+# Disable CTest testcases & install in cpp-ipfs-http-client
+set (BUILD_TESTING OFF CACHE BOOL "Disable CTest" FORCE)
+set (DISABLE_INSTALL ON CACHE BOOL "Disable Install" FORCE)
+
+add_subdirectory (lib/commonmarker/src)
+add_subdirectory (lib/commonmarker/extensions)
+add_subdirectory (lib/ipfs-http-client)
+add_subdirectory (lib/whereami)
+add_subdirectory (src)
+
+# Additional install files
+if(WIN32)
+  # Windows specific
+  install(DIRECTORY packaging_win/ DESTINATION .)
+  install(PROGRAMS go-ipfs/ipfs.exe DESTINATION bin)
+else()
+  # UNIX specific
+  install(FILES misc/libreweb-browser.desktop DESTINATION share/applications)
+  install(PROGRAMS go-ipfs/ipfs DESTINATION bin)
+endif()
+# General
+install(DIRECTORY images DESTINATION share/libreweb)
+install(FILES images/icons/libreweb-browser.png DESTINATION share/icons/hicolor/48x48/apps)
+install(FILES images/icons/libreweb-browser.svg DESTINATION share/icons/hicolor/scalable/apps)
diff --git a/README.md b/README.md
new file mode 100644
index 00000000..e7bc8484
--- /dev/null
+++ b/README.md
@@ -0,0 +1,191 @@
+# LibreWeb Browser
+
+LibreWeb is an **open-source decentralized web browser**, leveraging IPFS. What would you do different; if you could **reinvent** The Internet in 21st century?  
+With all the knowledge and new technologies available today. I was inspired by Douglas Engelbart, Tim Berners-Lee and Ted Nelson as well as projects like IPFS, Jekyll, ARPANET and more.
+
+[![Pipeline](https://gitlab.melroy.org/libreweb/browser/badges/master/pipeline.svg)](https://gitlab.melroy.org/libreweb/browser/-/pipelines/latest)
+[![Telegram](https://img.shields.io/badge/chat-on%20telegram-brightgreen)](https://t.me/libreweb)
+[![Matrix](https://img.shields.io/badge/chat-on%20matrix-brightgreen)](https://matrix.to/#/#libreweb:melroy.org)
+[![Gitter](https://img.shields.io/badge/chat-on%20gitter-brightgreen)](https://gitter.im/LibreWeb/Browser)
+[![Roadmap](https://img.shields.io/badge/Roadmap-yellow)](https://gitlab.melroy.org/libreweb/browser/-/milestones)
+[![Release](https://img.shields.io/badge/Release-latest-orange)](https://gitlab.melroy.org/libreweb/browser/-/releases)
+
+*Note:* This project is still work in progress. However, we have a working [alpha version available](https://gitlab.melroy.org/libreweb/browser/-/releases).
+
+## For Users
+
+### Download
+
+Just download the latest LibreWeb release and get started:
+
+* [Download the latest release](https://gitlab.melroy.org/libreweb/browser/-/releases)
+
+### Documentation
+
+Visit the [dedicated documentation site](https://docs.libreweb.org) for *user* documentation.
+
+### Screenshots
+
+![Browser Screenshot](./misc/browser_screenshot.png)  
+![Browser Markdown Editor](./misc/browser_screenshot_2.png)
+
+### Community
+
+Join our [Telegram group](https://t.me/libreweb) or [Matrix channel](https://matrix.to/#/#libreweb:melroy.org?via=melroy.org) and become part of our community!
+
+### Ideas / Features
+
+The current success criteria:
+
+* Everyone should be able to easily **read** and **create** a site/blog/news page and publish the content online (without minimal technical knowledge);
+* Built-in easy-to-use **editor** (whenever you want to publish some content without programming language knowledge);
+* **Decentralized** (no single-point of failure or censorship), like: P2P, DHT and IPFS;
+* *No* client-server approach (the client is also the server and visa versa) - think **mesh network**.
+* **Encrypted** transfers;
+* Data is stored **redundantly** within the network (no single-point of failure);
+* **Versioning**/revisions of content and documenents (automatically solves broken 'links', that can't happy anymore);
+* Publisher user should be able to add additional information about the document/page, eg. title or path (similar in how Jekyll is using the `YML` format for meta data)
+* Human-readable source-code (eg. `Markdown` format, could be extended as well);
+* You are in control about the layout and styling (just like with e-books);
+* Content is King;
+* Fast and Extensible!
+
+*Note:* Since HyperText (so is HTML) is not used, you can even ditch the HTTP protocol. However TLS, for encryption, can still be used.
+
+---
+
+The sections below are mainly relevant for software developers, who want to contribute or help LibreWeb Browser.
+
+## For Developers
+
+Decentralized Browser is written C++ together with some [external libraries](/lib). LibreWeb is using the [cmark-gfm](https://github.com/github/cmark-gfm) library for example, which is used for CommonMark (markdown) parsing.  
+We're using markdown as the source-code of the content/site. No HTML and JavaScript anymore, content is king after all.
+
+LibreWeb Browser is also using [Gnome GTK3](https://developer.gnome.org/gtk3/stable/) framework for the GUI. Using the C++ bindings, called [Gtkmm](https://gtkmm.org/en/).
+
+### Development Environment
+
+Personally, I'm using VSCodium editor, with the following extensions installed: `C/C++`, `CMake`, `CMake Tools`, `PlantUML`, `Markdown All in One`, `vscode-icons` and `GitLab Workflow`.
+
+But that is up to you.
+
+### Build Dependencies
+
+For the GNU/Linux build you need at least:
+
+* GCC 9 or higher (`build-essential`, `g++-9`)
+* CMake (Package: `cmake`)
+* Ninja build system (Package: `ninja-build`)
+* Libcurl (Package: `libcurl4-openssl-dev`)
+* GTK & Pango (including C++ bindings):
+  * Package: `libgtkmm-3.0-dev` under Debian based distros
+* Clang-format (Package: `clang-format`)
+
+*Note:* For cross-compiling towards Windows, see the cross-compile section below.
+
+### Build
+
+Clone the source-code with SSH (do not forget `--recurse-submodules`):
+
+```sh
+git clone --recurse-submodules -j5 git@gitlab.melroy.org:libreweb/browser.git
+```
+
+Start the Linux build, which is using CMake and Ninja build system, using the wrapper script:
+
+```sh
+./scripts/build-lnx.sh
+```
+
+Optionally, use the VSCode `CMake Tools` extension to start the build or build with debug targets.
+
+Build a release target, including packaging under GNU/Linux, using: `./scripts/build-lnx-prod.sh`
+
+*Note:* Root access is required for Linux packaging; add `/opt/mxe/usr/bin` to the secure_path using: `sudo visudo`.
+
+### C++ Coding Style Guidelines
+
+#### Automated Clang-format
+
+We use our [own Clang LLVM C++ Programming Style Format](.clang-format), using [clang-format](https://clang.llvm.org/docs/ClangFormat.html) command.
+
+To automatically comply to our style format execute following script (inplace edits are performed for you):
+
+```sh
+./scripts/fix-format.sh
+```
+
+Check only for errors, run: `./scripts/check-format.sh`
+
+#### Core Guidelines
+
+We also tend to follow the [C++ Core Guidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines) as much as possible.
+
+### Doxygen
+
+See latest [Developer Documentation](https://gitlab.melroy.org/libreweb/browser/-/jobs/artifacts/master/file/build/docs/html/index.html?job=doxygen).
+
+Doxygen is build by default. You can disable the doxygen build, if you want, using: `cmake -DDOXYGEN:BOOL=FALSE ..`
+
+### Memory Leaks
+
+First **build** the (GNU/Linux) target with *debug symbols*. Build target file should be present: `./build/bin/libreweb-browser`.
+
+Next, check for memory leaks using `valgrind` by executing:
+
+```sh
+./scripts/valgrind.sh
+```
+
+### Cross-compiling Build Dependencies
+
+For the [cross-compiling](https://en.wikipedia.org/wiki/Cross_compiler) towards **Windows** (while under GNU/Linux), you need at least:
+
+* [MXE Gtkmm3 / Curl Binary packages](mxe.cc) (static build using Meson build with GCC11, see below for more info)
+* CMake (Package: `cmake`)
+* Ninja (Package: `ninja-build`)
+* Nullsoft Scriptable Install System (Package: `nsis`)
+
+For more information and the latest pre-build GTK3 Windows download, please my other [GTK 3 bundle repo](https://gitlab.melroy.org/melroy/gtk-3-bundle-for-windows).
+
+**Note:** We're currently busy trying to upgrade the [whole GTK stack](https://github.com/danger89/mxe/tree/update_gtk).
+
+We used the following build command to get the Windows dependencies and MXE cross-compilation toolset:
+
+```sh
+make gtkmm3 curl -j 16 MXE_TARGETS='x86_64-w64-mingw32.static' MXE_PLUGIN_DIRS='plugins/gcc10'
+```
+
+*NOTE:* Soon we need gcc11, but GTK3 upstream needs to create a new release that fixes the GCC11 builds.
+
+Add the following line to the end of the `~/.bashrc` file:
+
+```bash
+export PATH="/opt/mxe/usr/bin:$PATH"
+```
+
+#### Cross-compile Build
+
+Please, be sure you meet all the requirements above. So your MXE environment should be ready in: `/opt/mxe/usr`.
+
+To start the *cross-compile* build towards Windows 64-bit (using GNU/Linux as host) you can use the commands below.
+
+Build a Windows development release:
+
+```sh
+./scripts/build-win.sh
+```
+
+Build a production release + packaging with [NSIS](https://sourceforge.net/projects/nsis/), execute the following:
+
+```sh
+./scripts/build-win-prod.sh
+```
+
+See also: [Windows readme](Windows.md) file.
+
+### Research
+
+For [research document](https://gitlab.melroy.org/libreweb/research_lab/-/blob/master/research.md) plus findings including explanation (like [diagrams](https://gitlab.melroy.org/libreweb/research_lab/-/blob/master/diagrams.md)) see the:
+
+* [LibreWeb Research Lab Project](https://gitlab.melroy.org/libreweb/research_lab/-/tree/master)
diff --git a/lib/commonmarker/extensions/highlight.c b/lib/commonmarker/extensions/highlight.c
new file mode 100644
index 00000000..012e5655
--- /dev/null
+++ b/lib/commonmarker/extensions/highlight.c
@@ -0,0 +1,128 @@
+#include "highlight.h"
+#include <parser.h>
+#include <render.h>
+
+cmark_node_type CMARK_NODE_HIGHLIGHT;
+
+static cmark_node *match(cmark_syntax_extension *self, cmark_parser *parser,
+                         cmark_node *parent, unsigned char character,
+                         cmark_inline_parser *inline_parser) {
+  cmark_node *res = NULL;
+  int left_flanking, right_flanking, punct_before, punct_after, delims;
+  char buffer[101] = {0};
+
+  if (character != '=')
+    return NULL;
+
+  delims = cmark_inline_parser_scan_delimiters(
+      inline_parser, sizeof(buffer) - 1, '=',
+      &left_flanking,
+      &right_flanking, &punct_before, &punct_after);
+
+  memset(buffer, '=', delims);
+  buffer[delims] = 0;
+
+  res = cmark_node_new_with_mem(CMARK_NODE_TEXT, parser->mem);
+  cmark_node_set_literal(res, buffer);
+  res->start_line = res->end_line = cmark_inline_parser_get_line(inline_parser);
+  res->start_column = cmark_inline_parser_get_column(inline_parser) - delims;
+
+  // '=' char needs to be matched 2x
+  if ((left_flanking || right_flanking) && (delims == 2)) {
+    cmark_inline_parser_push_delimiter(inline_parser, character, left_flanking,
+                                       right_flanking, res);
+  }
+
+  return res;
+}
+
+static delimiter *insert(cmark_syntax_extension *self, cmark_parser *parser,
+                         cmark_inline_parser *inline_parser, delimiter *opener,
+                         delimiter *closer) {
+  cmark_node *highlight;
+  cmark_node *tmp, *next;
+  delimiter *delim, *tmp_delim;
+  delimiter *res = closer->next;
+
+  highlight = opener->inl_text;
+
+  if (opener->inl_text->as.literal.len != closer->inl_text->as.literal.len)
+    goto done;
+
+  if (!cmark_node_set_type(highlight, CMARK_NODE_HIGHLIGHT))
+    goto done;
+
+  cmark_node_set_syntax_extension(highlight, self);
+
+  tmp = cmark_node_next(opener->inl_text);
+
+  while (tmp) {
+    if (tmp == closer->inl_text)
+      break;
+    next = cmark_node_next(tmp);
+    cmark_node_append_child(highlight, tmp);
+    tmp = next;
+  }
+
+  highlight->end_column = closer->inl_text->start_column + closer->inl_text->as.literal.len - 1;
+  cmark_node_free(closer->inl_text);
+
+  delim = closer;
+  while (delim != NULL && delim != opener) {
+    tmp_delim = delim->previous;
+    cmark_inline_parser_remove_delimiter(inline_parser, delim);
+    delim = tmp_delim;
+  }
+
+  cmark_inline_parser_remove_delimiter(inline_parser, opener);
+
+done:
+  return res;
+}
+
+static const char *get_type_string(cmark_syntax_extension *extension,
+                                   cmark_node *node) {
+  return node->type == CMARK_NODE_HIGHLIGHT ? "highlight" : "<unknown>";
+}
+
+static int can_contain(cmark_syntax_extension *extension, cmark_node *node,
+                       cmark_node_type child_type) {
+  if (node->type != CMARK_NODE_HIGHLIGHT)
+    return false;
+
+  return CMARK_NODE_TYPE_INLINE_P(child_type);
+}
+
+static void commonmark_render(cmark_syntax_extension *extension,
+                              cmark_renderer *renderer, cmark_node *node,
+                              cmark_event_type ev_type, int options) {
+  renderer->out(renderer, node, "==", false, LITERAL);
+}
+
+static void plaintext_render(cmark_syntax_extension *extension,
+                             cmark_renderer *renderer, cmark_node *node,
+                             cmark_event_type ev_type, int options) {
+  renderer->out(renderer, node, "=", false, LITERAL);
+}
+
+cmark_syntax_extension *create_highlight_extension(void) {
+  cmark_syntax_extension *ext = cmark_syntax_extension_new("highlight");
+  cmark_llist *special_chars = NULL;
+
+  cmark_syntax_extension_set_get_type_string_func(ext, get_type_string);
+  cmark_syntax_extension_set_can_contain_func(ext, can_contain);
+  cmark_syntax_extension_set_commonmark_render_func(ext, commonmark_render);
+  cmark_syntax_extension_set_plaintext_render_func(ext, plaintext_render);
+  CMARK_NODE_HIGHLIGHT = cmark_syntax_extension_add_node(1);
+
+  cmark_syntax_extension_set_match_inline_func(ext, match);
+  cmark_syntax_extension_set_inline_from_delim_func(ext, insert);
+
+  cmark_mem *mem = cmark_get_default_mem_allocator();
+  special_chars = cmark_llist_append(mem, special_chars, (void *)'=');
+  cmark_syntax_extension_set_special_inline_chars(ext, special_chars);
+
+  cmark_syntax_extension_set_emphasis(ext, 1);
+
+  return ext;
+}
diff --git a/lib/commonmarker/extensions/highlight.h b/lib/commonmarker/extensions/highlight.h
new file mode 100644
index 00000000..25ed608c
--- /dev/null
+++ b/lib/commonmarker/extensions/highlight.h
@@ -0,0 +1,13 @@
+/**
+ * Cmark Highlight inline extension by Melroy van den Berg
+ * Usage: ==Highlight text==
+ */
+#ifndef CMARK_GFM_HIGHLIGHT_H
+#define CMARK_GFM_HIGHLIGHT_H
+
+#include "cmark-gfm-core-extensions.h"
+
+extern cmark_node_type CMARK_NODE_HIGHLIGHT;
+cmark_syntax_extension *create_highlight_extension(void);
+
+#endif
diff --git a/lib/commonmarker/extensions/strikethrough.c b/lib/commonmarker/extensions/strikethrough.c
new file mode 100644
index 00000000..8145d23b
--- /dev/null
+++ b/lib/commonmarker/extensions/strikethrough.c
@@ -0,0 +1,167 @@
+#include "strikethrough.h"
+#include <parser.h>
+#include <render.h>
+
+cmark_node_type CMARK_NODE_STRIKETHROUGH;
+
+static cmark_node *match(cmark_syntax_extension *self, cmark_parser *parser,
+                         cmark_node *parent, unsigned char character,
+                         cmark_inline_parser *inline_parser) {
+  cmark_node *res = NULL;
+  int left_flanking, right_flanking, punct_before, punct_after, delims;
+  char buffer[101];
+
+  if (character != '~')
+    return NULL;
+
+  delims = cmark_inline_parser_scan_delimiters(
+      inline_parser, sizeof(buffer) - 1, '~',
+      &left_flanking,
+      &right_flanking, &punct_before, &punct_after);
+
+  memset(buffer, '~', delims);
+  buffer[delims] = 0;
+
+  res = cmark_node_new_with_mem(CMARK_NODE_TEXT, parser->mem);
+  cmark_node_set_literal(res, buffer);
+  res->start_line = res->end_line = cmark_inline_parser_get_line(inline_parser);
+  res->start_column = cmark_inline_parser_get_column(inline_parser) - delims;
+
+  if ((left_flanking || right_flanking) &&
+      (delims == 2 || (!(parser->options & CMARK_OPT_STRIKETHROUGH_DOUBLE_TILDE) && delims == 1))) {
+    cmark_inline_parser_push_delimiter(inline_parser, character, left_flanking,
+                                       right_flanking, res);
+  }
+
+  return res;
+}
+
+static delimiter *insert(cmark_syntax_extension *self, cmark_parser *parser,
+                         cmark_inline_parser *inline_parser, delimiter *opener,
+                         delimiter *closer) {
+  cmark_node *strikethrough;
+  cmark_node *tmp, *next;
+  delimiter *delim, *tmp_delim;
+  delimiter *res = closer->next;
+
+  strikethrough = opener->inl_text;
+
+  if (opener->inl_text->as.literal.len != closer->inl_text->as.literal.len)
+    goto done;
+
+  if (!cmark_node_set_type(strikethrough, CMARK_NODE_STRIKETHROUGH))
+    goto done;
+
+  cmark_node_set_syntax_extension(strikethrough, self);
+
+  tmp = cmark_node_next(opener->inl_text);
+
+  while (tmp) {
+    if (tmp == closer->inl_text)
+      break;
+    next = cmark_node_next(tmp);
+    cmark_node_append_child(strikethrough, tmp);
+    tmp = next;
+  }
+
+  strikethrough->end_column = closer->inl_text->start_column + closer->inl_text->as.literal.len - 1;
+  cmark_node_free(closer->inl_text);
+
+  delim = closer;
+  while (delim != NULL && delim != opener) {
+    tmp_delim = delim->previous;
+    cmark_inline_parser_remove_delimiter(inline_parser, delim);
+    delim = tmp_delim;
+  }
+
+  cmark_inline_parser_remove_delimiter(inline_parser, opener);
+
+done:
+  return res;
+}
+
+static const char *get_type_string(cmark_syntax_extension *extension,
+                                   cmark_node *node) {
+  return node->type == CMARK_NODE_STRIKETHROUGH ? "strikethrough" : "<unknown>";
+}
+
+static int can_contain(cmark_syntax_extension *extension, cmark_node *node,
+                       cmark_node_type child_type) {
+  if (node->type != CMARK_NODE_STRIKETHROUGH)
+    return false;
+
+  return CMARK_NODE_TYPE_INLINE_P(child_type);
+}
+
+static void commonmark_render(cmark_syntax_extension *extension,
+                              cmark_renderer *renderer, cmark_node *node,
+                              cmark_event_type ev_type, int options) {
+  renderer->out(renderer, node, "~~", false, LITERAL);
+}
+
+static void latex_render(cmark_syntax_extension *extension,
+                         cmark_renderer *renderer, cmark_node *node,
+                         cmark_event_type ev_type, int options) {
+  // requires \usepackage{ulem}
+  bool entering = (ev_type == CMARK_EVENT_ENTER);
+  if (entering) {
+    renderer->out(renderer, node, "\\sout{", false, LITERAL);
+  } else {
+    renderer->out(renderer, node, "}", false, LITERAL);
+  }
+}
+
+static void man_render(cmark_syntax_extension *extension,
+                       cmark_renderer *renderer, cmark_node *node,
+                       cmark_event_type ev_type, int options) {
+  bool entering = (ev_type == CMARK_EVENT_ENTER);
+  if (entering) {
+    renderer->cr(renderer);
+    renderer->out(renderer, node, ".ST \"", false, LITERAL);
+  } else {
+    renderer->out(renderer, node, "\"", false, LITERAL);
+    renderer->cr(renderer);
+  }
+}
+
+static void html_render(cmark_syntax_extension *extension,
+                        cmark_html_renderer *renderer, cmark_node *node,
+                        cmark_event_type ev_type, int options) {
+  bool entering = (ev_type == CMARK_EVENT_ENTER);
+  if (entering) {
+    cmark_strbuf_puts(renderer->html, "<del>");
+  } else {
+    cmark_strbuf_puts(renderer->html, "</del>");
+  }
+}
+
+static void plaintext_render(cmark_syntax_extension *extension,
+                             cmark_renderer *renderer, cmark_node *node,
+                             cmark_event_type ev_type, int options) {
+  renderer->out(renderer, node, "~", false, LITERAL);
+}
+
+cmark_syntax_extension *create_strikethrough_extension(void) {
+  cmark_syntax_extension *ext = cmark_syntax_extension_new("strikethrough");
+  cmark_llist *special_chars = NULL;
+
+  cmark_syntax_extension_set_get_type_string_func(ext, get_type_string);
+  cmark_syntax_extension_set_can_contain_func(ext, can_contain);
+  cmark_syntax_extension_set_commonmark_render_func(ext, commonmark_render);
+  cmark_syntax_extension_set_latex_render_func(ext, latex_render);
+  cmark_syntax_extension_set_man_render_func(ext, man_render);
+  cmark_syntax_extension_set_html_render_func(ext, html_render);
+  cmark_syntax_extension_set_plaintext_render_func(ext, plaintext_render);
+  CMARK_NODE_STRIKETHROUGH = cmark_syntax_extension_add_node(1);
+
+  cmark_syntax_extension_set_match_inline_func(ext, match);
+  cmark_syntax_extension_set_inline_from_delim_func(ext, insert);
+
+  cmark_mem *mem = cmark_get_default_mem_allocator();
+  special_chars = cmark_llist_append(mem, special_chars, (void *)'~');
+  cmark_syntax_extension_set_special_inline_chars(ext, special_chars);
+
+  cmark_syntax_extension_set_emphasis(ext, 1);
+
+  return ext;
+}
diff --git a/lib/commonmarker/extensions/strikethrough.h b/lib/commonmarker/extensions/strikethrough.h
new file mode 100644
index 00000000..a52a2b4a
--- /dev/null
+++ b/lib/commonmarker/extensions/strikethrough.h
@@ -0,0 +1,9 @@
+#ifndef CMARK_GFM_STRIKETHROUGH_H
+#define CMARK_GFM_STRIKETHROUGH_H
+
+#include "cmark-gfm-core-extensions.h"
+
+extern cmark_node_type CMARK_NODE_STRIKETHROUGH;
+cmark_syntax_extension *create_strikethrough_extension(void);
+
+#endif
diff --git a/lib/commonmarker/extensions/subscript.c b/lib/commonmarker/extensions/subscript.c
new file mode 100644
index 00000000..c317972d
--- /dev/null
+++ b/lib/commonmarker/extensions/subscript.c
@@ -0,0 +1,127 @@
+#include "subscript.h"
+#include <parser.h>
+#include <render.h>
+
+cmark_node_type CMARK_NODE_SUBSCRIPT;
+
+static cmark_node *match(cmark_syntax_extension *self, cmark_parser *parser,
+                         cmark_node *parent, unsigned char character,
+                         cmark_inline_parser *inline_parser) {
+  cmark_node *res = NULL;
+  int left_flanking, right_flanking, punct_before, punct_after, delims;
+  char buffer[101] = {0};
+
+  if (character != '%')
+    return NULL;
+
+  delims = cmark_inline_parser_scan_delimiters(
+      inline_parser, sizeof(buffer) - 1, '%',
+      &left_flanking,
+      &right_flanking, &punct_before, &punct_after);
+
+  memset(buffer, '%', delims);
+  buffer[delims] = 0;
+
+  res = cmark_node_new_with_mem(CMARK_NODE_TEXT, parser->mem);
+  cmark_node_set_literal(res, buffer);
+  res->start_line = res->end_line = cmark_inline_parser_get_line(inline_parser);
+  res->start_column = cmark_inline_parser_get_column(inline_parser) - delims;
+
+  if ((left_flanking || right_flanking) && (delims == 1)) {
+    cmark_inline_parser_push_delimiter(inline_parser, character, left_flanking,
+                                       right_flanking, res);
+  }
+
+  return res;
+}
+
+static delimiter *insert(cmark_syntax_extension *self, cmark_parser *parser,
+                         cmark_inline_parser *inline_parser, delimiter *opener,
+                         delimiter *closer) {
+  cmark_node *subscript;
+  cmark_node *tmp, *next;
+  delimiter *delim, *tmp_delim;
+  delimiter *res = closer->next;
+
+  subscript = opener->inl_text;
+
+  if (opener->inl_text->as.literal.len != closer->inl_text->as.literal.len)
+    goto done;
+
+  if (!cmark_node_set_type(subscript, CMARK_NODE_SUBSCRIPT))
+    goto done;
+
+  cmark_node_set_syntax_extension(subscript, self);
+
+  tmp = cmark_node_next(opener->inl_text);
+
+  while (tmp) {
+    if (tmp == closer->inl_text)
+      break;
+    next = cmark_node_next(tmp);
+    cmark_node_append_child(subscript, tmp);
+    tmp = next;
+  }
+
+  subscript->end_column = closer->inl_text->start_column + closer->inl_text->as.literal.len - 1;
+  cmark_node_free(closer->inl_text);
+
+  delim = closer;
+  while (delim != NULL && delim != opener) {
+    tmp_delim = delim->previous;
+    cmark_inline_parser_remove_delimiter(inline_parser, delim);
+    delim = tmp_delim;
+  }
+
+  cmark_inline_parser_remove_delimiter(inline_parser, opener);
+
+done:
+  return res;
+}
+
+static const char *get_type_string(cmark_syntax_extension *extension,
+                                   cmark_node *node) {
+  return node->type == CMARK_NODE_SUBSCRIPT ? "subscript" : "<unknown>";
+}
+
+static int can_contain(cmark_syntax_extension *extension, cmark_node *node,
+                       cmark_node_type child_type) {
+  if (node->type != CMARK_NODE_SUBSCRIPT)
+    return false;
+
+  return CMARK_NODE_TYPE_INLINE_P(child_type);
+}
+
+static void commonmark_render(cmark_syntax_extension *extension,
+                              cmark_renderer *renderer, cmark_node *node,
+                              cmark_event_type ev_type, int options) {
+  renderer->out(renderer, node, "~", false, LITERAL);
+}
+
+static void plaintext_render(cmark_syntax_extension *extension,
+                             cmark_renderer *renderer, cmark_node *node,
+                             cmark_event_type ev_type, int options) {
+  renderer->out(renderer, node, "~", false, LITERAL);
+}
+
+cmark_syntax_extension *create_subscript_extension(void) {
+  cmark_syntax_extension *ext = cmark_syntax_extension_new("subscript");
+  cmark_llist *special_chars = NULL;
+
+  cmark_syntax_extension_set_get_type_string_func(ext, get_type_string);
+  cmark_syntax_extension_set_can_contain_func(ext, can_contain);
+  cmark_syntax_extension_set_commonmark_render_func(ext, commonmark_render);
+  cmark_syntax_extension_set_plaintext_render_func(ext, plaintext_render);
+  CMARK_NODE_SUBSCRIPT = cmark_syntax_extension_add_node(1);
+
+  cmark_syntax_extension_set_match_inline_func(ext, match);
+  cmark_syntax_extension_set_inline_from_delim_func(ext, insert);
+
+  cmark_mem *mem = cmark_get_default_mem_allocator();
+  special_chars = cmark_llist_append(mem, special_chars, (void *)'%');
+  cmark_syntax_extension_set_special_inline_chars(ext, special_chars);
+
+  cmark_syntax_extension_set_emphasis(ext, 1);
+
+  return ext;
+}
diff --git a/lib/commonmarker/extensions/subscript.h b/lib/commonmarker/extensions/subscript.h
new file mode 100644
index 00000000..94058b5a
--- /dev/null
+++ b/lib/commonmarker/extensions/subscript.h
@@ -0,0 +1,13 @@
+/**
+ * Cmark Subscript inline extension by Melroy van den Berg
+ * Usage: %Subscript%
+ */
+#ifndef CMARK_GFM_SUBSCRIPT_H
+#define CMARK_GFM_SUBSCRIPT_H
+
+#include "cmark-gfm-core-extensions.h"
+
+extern cmark_node_type CMARK_NODE_SUBSCRIPT;
+cmark_syntax_extension *create_subscript_extension(void);
+
+#endif
diff --git a/lib/commonmarker/extensions/superscript.c b/lib/commonmarker/extensions/superscript.c
new file mode 100644
index 00000000..2939408b
--- /dev/null
+++ b/lib/commonmarker/extensions/superscript.c
@@ -0,0 +1,127 @@
+#include "superscript.h"
+#include <parser.h>
+#include <render.h>
+
+cmark_node_type CMARK_NODE_SUPERSCRIPT;
+
+static cmark_node *match(cmark_syntax_extension *self, cmark_parser *parser,
+                         cmark_node *parent, unsigned char character,
+                         cmark_inline_parser *inline_parser) {
+  cmark_node *res = NULL;
+  int left_flanking, right_flanking, punct_before, punct_after, delims;
+  char buffer[101] = {0};
+
+  if (character != '^')
+    return NULL;
+
+  delims = cmark_inline_parser_scan_delimiters(
+      inline_parser, sizeof(buffer) - 1, '^',
+      &left_flanking,
+      &right_flanking, &punct_before, &punct_after);
+
+  memset(buffer, '^', delims);
+  buffer[delims] = 0;
+
+  res = cmark_node_new_with_mem(CMARK_NODE_TEXT, parser->mem);
+  cmark_node_set_literal(res, buffer);
+  res->start_line = res->end_line = cmark_inline_parser_get_line(inline_parser);
+  res->start_column = cmark_inline_parser_get_column(inline_parser) - delims;
+
+  if ((left_flanking || right_flanking) && (delims == 1)) {
+    cmark_inline_parser_push_delimiter(inline_parser, character, left_flanking,
+                                       right_flanking, res);
+  }
+
+  return res;
+}
+
+static delimiter *insert(cmark_syntax_extension *self, cmark_parser *parser,
+                         cmark_inline_parser *inline_parser, delimiter *opener,
+                         delimiter *closer) {
+  cmark_node *superscript;
+  cmark_node *tmp, *next;
+  delimiter *delim, *tmp_delim;
+  delimiter *res = closer->next;
+
+  superscript = opener->inl_text;
+
+  if (opener->inl_text->as.literal.len != closer->inl_text->as.literal.len)
+    goto done;
+
+  if (!cmark_node_set_type(superscript, CMARK_NODE_SUPERSCRIPT))
+    goto done;
+
+  cmark_node_set_syntax_extension(superscript, self);
+
+  tmp = cmark_node_next(opener->inl_text);
+
+  while (tmp) {
+    if (tmp == closer->inl_text)
+      break;
+    next = cmark_node_next(tmp);
+    cmark_node_append_child(superscript, tmp);
+    tmp = next;
+  }
+
+  superscript->end_column = closer->inl_text->start_column + closer->inl_text->as.literal.len - 1;
+  cmark_node_free(closer->inl_text);
+
+  delim = closer;
+  while (delim != NULL && delim != opener) {
+    tmp_delim = delim->previous;
+    cmark_inline_parser_remove_delimiter(inline_parser, delim);
+    delim = tmp_delim;
+  }
+
+  cmark_inline_parser_remove_delimiter(inline_parser, opener);
+
+done:
+  return res;
+}
+
+static const char *get_type_string(cmark_syntax_extension *extension,
+                                   cmark_node *node) {
+  return node->type == CMARK_NODE_SUPERSCRIPT ? "superscript" : "<unknown>";
+}
+
+static int can_contain(cmark_syntax_extension *extension, cmark_node *node,
+                       cmark_node_type child_type) {
+  if (node->type != CMARK_NODE_SUPERSCRIPT)
+    return false;
+
+  return CMARK_NODE_TYPE_INLINE_P(child_type);
+}
+
+static void commonmark_render(cmark_syntax_extension *extension,
+                              cmark_renderer *renderer, cmark_node *node,
+                              cmark_event_type ev_type, int options) {
+  renderer->out(renderer, node, "^", false, LITERAL);
+}
+
+static void plaintext_render(cmark_syntax_extension *extension,
+                             cmark_renderer *renderer, cmark_node *node,
+                             cmark_event_type ev_type, int options) {
+  renderer->out(renderer, node, "^", false, LITERAL);
+}
+
+cmark_syntax_extension *create_superscript_extension(void) {
+  cmark_syntax_extension *ext = cmark_syntax_extension_new("superscript");
+  cmark_llist *special_chars = NULL;
+
+  cmark_syntax_extension_set_get_type_string_func(ext, get_type_string);
+  cmark_syntax_extension_set_can_contain_func(ext, can_contain);
+  cmark_syntax_extension_set_commonmark_render_func(ext, commonmark_render);
+  cmark_syntax_extension_set_plaintext_render_func(ext, plaintext_render);
+  CMARK_NODE_SUPERSCRIPT = cmark_syntax_extension_add_node(1);
+
+  cmark_syntax_extension_set_match_inline_func(ext, match);
+  cmark_syntax_extension_set_inline_from_delim_func(ext, insert);
+
+  cmark_mem *mem = cmark_get_default_mem_allocator();
+  special_chars = cmark_llist_append(mem, special_chars, (void *)'^');
+  cmark_syntax_extension_set_special_inline_chars(ext, special_chars);
+
+  cmark_syntax_extension_set_emphasis(ext, 1);
+
+  return ext;
+}
diff --git a/lib/commonmarker/extensions/superscript.h b/lib/commonmarker/extensions/superscript.h
new file mode 100644
index 00000000..79e56f0b
--- /dev/null
+++ b/lib/commonmarker/extensions/superscript.h
@@ -0,0 +1,13 @@
+/**
+ * Cmark Superscript inline extension by Melroy van den Berg
+ * Usage: ^Superscript^
+ */
+#ifndef CMARK_GFM_SUPERSCRIPT_H
+#define CMARK_GFM_SUPERSCRIPT_H
+
+#include "cmark-gfm-core-extensions.h"
+
+extern cmark_node_type CMARK_NODE_SUPERSCRIPT;
+cmark_syntax_extension *create_superscript_extension(void);
+
+#endif
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
new file mode 100644
index 00000000..e6c59983
--- /dev/null
+++ b/src/CMakeLists.txt
@@ -0,0 +1,125 @@
+include(${CMAKE_SOURCE_DIR}/cmake/GSettings.cmake)
+
+set(PROJECT_TARGET libreweb-browser)
+set(THREADS_PREFER_PTHREAD_FLAG ON)
+
+# Find required dependencies
+find_package(Threads REQUIRED)
+find_package(PkgConfig REQUIRED)
+pkg_check_modules(GTKMM REQUIRED gtkmm-3.0)
+
+# Generate Project version header file
+configure_file(${CMAKE_CURRENT_SOURCE_DIR}/project_config.h.in ${CMAKE_CURRENT_BINARY_DIR}/project_config.h)
+
+# In order to find project_config.h
+set(CMAKE_INCLUDE_CURRENT_DIR ON)
+
+# Source code
+set(HEADERS
+    about.h
+    draw.h
+    file.h
+    ipfs.h
+    middleware.h
+    mainwindow.h
+    md-parser.h
+    menu.h
+    ipfs-daemon.h
+    option-group.h
+    source-code-dialog.h
+)
+set(SOURCES 
+  main.cc
+  about.cc
+  draw.cc
+  file.cc
+  ipfs.cc
+  middleware.cc
+  mainwindow.cc
+  md-parser.cc
+  menu.cc
+  ipfs-daemon.cc
+  option-group.cc
+  source-code-dialog.cc
+  ${HEADERS}
+)
+
+# Install and recompile glib gsettings schema
+add_schema("org.libreweb.browser.gschema.xml" GSCHEMA_RING)
+
+# Only for Windows
+if(WIN32)
+    # Windows Schema files
+    set(WINDOWS_SCHEMA_FILES
+        org.gtk.Settings.ColorChooser.gschema.xml
+        org.gtk.Settings.Debug.gschema.xml
+        org.gtk.Settings.EmojiChooser.gschema.xml
+        org.gtk.Settings.FileChooser.gschema.xml
+    )
+    message(STATUS "Add Windows Schema files")
+    foreach(SCHEMA_FILE ${WINDOWS_SCHEMA_FILES})
+        add_schema(${SCHEMA_FILE} GSCHEMA_RING)
+    endforeach(SCHEMA_FILE)
+
+    # Text format Windows resource file for Resource Compiler (rc)
+    set(WINDOWS_RES_IN ${CMAKE_SOURCE_DIR}/misc/libreweb.rc.in)
+    set(WINDOWS_RES ${CMAKE_CURRENT_BINARY_DIR}/libreweb.rc)
+    configure_file(${WINDOWS_RES_IN} ${WINDOWS_RES} @ONLY)
+	# Set a default rc compiler if it was not defined yet
+	if(NOT CMAKE_RC_COMPILER)
+		set(CMAKE_RC_COMPILER windres)
+	endif()
+	enable_language(RC)
+	set(CMAKE_RC_COMPILE_OBJECT "<CMAKE_RC_COMPILER> -Ocoff -o <OBJECT> <SOURCE>")
+	set_source_files_properties(${WINDOWS_RES} PROPERTIES LANGUAGE RC)
+endif()
+
+add_executable(${PROJECT_TARGET} ${GSCHEMA_RING} ${WINDOWS_RES} ${SOURCES})
+
+## Definitions just in case
+# Define _WIN32 for Windows platforms
+if(WIN32)
+    target_compile_definitions(${PROJECT_TARGET} PRIVATE _WIN32)
+endif()
+# Define __linux__ for Unix platforms
+if (UNIX)
+    target_compile_definitions(${PROJECT_TARGET} PRIVATE __linux__)
+endif()
+
+# Add fallback for std filesystem in older GCC versions
+if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
+    if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS 5.4)
+        message(FATAL_ERROR "You are on an extremely old version of GCC. Please update your compiler to at least GCC 8.0, preferably latest")
+    elseif (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 9.0)
+        message(WARNING "Old Version of GCC detected. Using Legacy C++ support")
+        # Add stdc++fs library in older GCC compiler versions
+        set(CXX_FILESYSTEM_LIBRARIES "stdc++fs")
+        target_compile_definitions(${PROJECT_TARGET} PUBLIC LEGACY_CXX)
+    endif()
+endif()
+
+# Get include list the cmark binary directory for the generated config.h, .._version.h & .._export.h files
+# Get include list the cmark extensions binary directory for the generated ..._export.h file
+get_property(CMAKE_BINARY_DIR GLOBAL PROPERTY COMMONMARKER_BINARY_DIR)
+get_property(CMAKE_EXTENSIONS_BINARY_DIR GLOBAL PROPERTY COMMONMARKER_EXTENSIONS_BINARY_DIR)
+
+target_include_directories(${PROJECT_TARGET} PRIVATE
+    ${CMAKE_BINARY_DIR}
+    ${CMAKE_EXTENSIONS_BINARY_DIR}
+    ${GTKMM_INCLUDE_DIRS}
+)
+target_link_directories(${PROJECT_TARGET} PRIVATE ${GTKMM_LIBRARY_DIRS})
+target_link_libraries(${PROJECT_TARGET} PRIVATE
+    LibCommonMarker
+    LibCommonMarkerExtensions
+    ipfs-http-client
+    whereami
+    Threads::Threads
+    ${CXX_FILESYSTEM_LIBRARIES}
+    ${GTKMM_LIBRARIES}
+    nlohmann_json::nlohmann_json
+)
+target_compile_options(${PROJECT_TARGET} PRIVATE ${GTKMM_CFLAGS_OTHER})
+
+# Install browser binary
+install(TARGETS ${PROJECT_TARGET} RUNTIME DESTINATION bin)
diff --git a/src/about.cc b/src/about.cc
new file mode 100644
index 00000000..a8fe0d5c
--- /dev/null
+++ b/src/about.cc
@@ -0,0 +1,73 @@
+#include "about.h"
+#include "project_config.h"
+
+#include <glibmm/fileutils.h>
+#include <glibmm/miscutils.h>
+
+About::About(Gtk::Window& parent)
+    : m_visitHomepage("https://libreweb.org/", "Visit Homepage"),
+      m_visitProjectLinkButton("https://gitlab.melroy.org/libreweb/browser", "Visit the GitLab Project")
+{
+  std::vector<Glib::ustring> devs;
+  devs.push_back("Melroy van den Berg <info@libreweb.org>");
+  std::vector<Glib::ustring> docs;
+  docs.push_back("Melroy van den Berg <info@libreweb.org>");
+
+  logo.set(this->getLogoImage());
+
+  set_transient_for(parent);
+  set_program_name("LibreWeb Browser");
+  set_version(PROJECT_VER);
+  set_comments("The fastest decentralized & distributed Browser on planet Earth.");
+  set_logo(logo.get_pixbuf());
+  set_copyright("Copyright ¬© 2020-2021 Melroy van den Berg");
+  set_authors(devs);
+  set_artists(devs);
+  set_documenters(docs);
+  set_license("");
+  set_license_type(Gtk::License::LICENSE_MIT_X11);
+  set_position(Gtk::WIN_POS_CENTER_ON_PARENT);
+
+  Gtk::Box* vbox = get_vbox();
+  vbox->pack_end(m_visitProjectLinkButton, Gtk::PackOptions::PACK_SHRINK);
+  vbox->pack_end(m_visitHomepage, Gtk::PackOptions::PACK_SHRINK);
+  m_visitHomepage.show();
+  m_visitProjectLinkButton.show();
+}
+
+void About::show_about()
+{
+  run();
+}
+
+void About::hide_about(__attribute__((unused)) int response)
+{
+  hide();
+}
+
+std::string About::getLogoImage()
+{
+  // Use data directory first, used when LibreWeb is installed (Linux or Windows)
+  for (std::string data_dir : Glib::get_system_data_dirs())
+  {
+    std::vector<std::string> path_builder{data_dir, "libreweb", "images", "browser_logo_small.png"};
+    std::string file_path = Glib::build_path(G_DIR_SEPARATOR_S, path_builder);
+    if (Glib::file_test(file_path, Glib::FileTest::FILE_TEST_IS_REGULAR))
+    {
+      return file_path;
+    }
+  }
+
+  // Try local path if the images are not installed (yet)
+  // When working directory is in the build/bin folder (relative path)
+  std::vector<std::string> path_builder{"..", "..", "images", "browser_logo_small.png"};
+  std::string file_path = Glib::build_path(G_DIR_SEPARATOR_S, path_builder);
+  if (Glib::file_test(file_path, Glib::FileTest::FILE_TEST_IS_REGULAR))
+  {
+    return file_path;
+  }
+  else
+  {
+    return "";
+  }
+}
diff --git a/src/about.h b/src/about.h
new file mode 100644
index 00000000..48602c7f
--- /dev/null
+++ b/src/about.h
@@ -0,0 +1,30 @@
+#ifndef ABOUT_H
+#define ABOUT_H
+
+#include <gtkmm/aboutdialog.h>
+#include <gtkmm/box.h>
+#include <gtkmm/image.h>
+#include <gtkmm/linkbutton.h>
+#include <gtkmm/window.h>
+
+/**
+ * \class About
+ * \brief About dialog window
+ */
+class About : public Gtk::AboutDialog
+{
+public:
+  explicit About(Gtk::Window& parent);
+  void show_about();
+  void hide_about(int response);
+
+protected:
+  Gtk::Image logo; /*!< The logo of the app */
+  Gtk::LinkButton m_visitHomepage;
+  Gtk::LinkButton m_visitProjectLinkButton;
+
+private:
+  std::string getLogoImage();
+  void visit_gitlab_project();
+};
+#endif
\ No newline at end of file
diff --git a/src/draw.cc b/src/draw.cc
new file mode 100644
index 00000000..1854db05
--- /dev/null
+++ b/src/draw.cc
@@ -0,0 +1,1604 @@
+#include "draw.h"
+#include "middleware.h"
+#include "node.h"
+#include "strikethrough.h"
+#include "syntax_extension.h"
+#include <cmark-gfm.h>
+#include <gdkmm/window.h>
+#include <glibmm.h>
+#include <gtkmm/textiter.h>
+#include <iostream>
+#include <regex>
+#include <stdexcept>
+
+Draw::Draw(Middleware& middleware)
+    : middleware(middleware),
+      buffer(Glib::unwrap(this->get_buffer())),
+      addViewSourceMenuItem(true),
+      headingLevel(0),
+      listLevel(0),
+      isBold(false),
+      isItalic(false),
+      isStrikethrough(false),
+      isHighlight(false),
+      isSuperscript(false),
+      isSubscript(false),
+      isQuote(false),
+      bulletListLevel(0),
+      orderedListLevel(0),
+      isOrderedList(false),
+      isLink(false),
+      hovingOverLink(false),
+      isUserAction(false)
+{
+  this->disableEdit();
+  set_top_margin(12);
+  set_left_margin(10);  // fallback
+  set_right_margin(10); // fallback
+  set_bottom_margin(0);
+  set_monospace(false);
+  set_app_paintable(true);
+  set_pixels_above_lines(1);
+  set_pixels_below_lines(2);
+  set_pixels_inside_wrap(2);
+  set_wrap_mode(Gtk::WrapMode::WRAP_WORD_CHAR);
+  set_has_tooltip();
+
+  // Set cursors
+  auto display = get_display();
+  normalCursor = Gdk::Cursor::create(display, "default");
+  linkCursor = Gdk::Cursor::create(display, "pointer");
+  textCursor = Gdk::Cursor::create(display, "text");
+
+  // Create text-tags
+  addTags();
+
+  // Connect Signals
+  signal_event_after().connect(sigc::mem_fun(this, &Draw::event_after));
+  signal_motion_notify_event().connect(sigc::mem_fun(this, &Draw::motion_notify_event));
+  signal_query_tooltip().connect(sigc::mem_fun(this, &Draw::query_tooltip));
+  signal_populate_popup().connect(sigc::mem_fun(this, &Draw::populate_popup));
+}
+
+/**
+ * \brief Adding tags.
+ * See also: https://gitlab.gnome.org/GNOME/gtkmm/-/blob/master/demos/gtk-demo/example_textview.cc#L100
+ */
+void Draw::addTags()
+{
+  auto buffer = get_buffer();
+  Glib::RefPtr<Gtk::TextBuffer::Tag> tmpTag;
+
+  // Italic / bold
+  buffer->create_tag("italic")->property_style() = Pango::Style::STYLE_ITALIC;
+  buffer->create_tag("bold")->property_weight() = Pango::Weight::WEIGHT_BOLD;
+
+  // Add headings
+  tmpTag = buffer->create_tag("heading1");
+  tmpTag->property_scale() = 2.3;
+  tmpTag->property_weight() = Pango::Weight::WEIGHT_BOLD;
+  tmpTag = buffer->create_tag("heading2");
+  tmpTag->property_scale() = 2.0;
+  tmpTag->property_weight() = Pango::Weight::WEIGHT_BOLD;
+  tmpTag = buffer->create_tag("heading3");
+  tmpTag->property_scale() = 1.8;
+  tmpTag->property_weight() = Pango::Weight::WEIGHT_BOLD;
+  tmpTag = buffer->create_tag("heading4");
+  tmpTag->property_scale() = 1.6;
+  tmpTag->property_weight() = Pango::Weight::WEIGHT_BOLD;
+  tmpTag = buffer->create_tag("heading5");
+  tmpTag->property_scale() = 1.4;
+  tmpTag->property_weight() = Pango::Weight::WEIGHT_BOLD;
+  tmpTag = buffer->create_tag("heading6");
+  tmpTag->property_scale() = 1.3;
+  tmpTag->property_weight() = Pango::Weight::WEIGHT_BOLD;
+  tmpTag->property_foreground() = "gray";
+
+  // Strikethrough, underline, double underline
+  buffer->create_tag("strikethrough")->property_strikethrough() = true;
+  buffer->create_tag("underline")->property_underline() = Pango::Underline::UNDERLINE_SINGLE;
+  buffer->create_tag("double_underline")->property_underline() = Pango::Underline::UNDERLINE_DOUBLE;
+
+  // Superscript/subscript
+  tmpTag = buffer->create_tag("superscript");
+  tmpTag->property_rise() = 6 * Pango::SCALE;
+  tmpTag->property_scale() = 0.8;
+  tmpTag = buffer->create_tag("subscript");
+  tmpTag->property_rise() = -6 * Pango::SCALE;
+  tmpTag->property_scale() = 0.8;
+
+  // code block
+  tmpTag = buffer->create_tag("code");
+  tmpTag->property_family() = "monospace";
+  tmpTag->property_foreground() = "#323232";
+  tmpTag->property_background() = "#e0e0e0";
+
+  // quote
+  tmpTag = buffer->create_tag("quote");
+  tmpTag->property_foreground() = "blue";
+  tmpTag->property_wrap_mode() = Gtk::WrapMode::WRAP_WORD;
+  tmpTag->property_indent() = 15;
+
+  // highlight
+  tmpTag = buffer->create_tag("highlight");
+  tmpTag->property_foreground() = "black";
+  tmpTag->property_background() = "#FFFF00";
+}
+
+/**
+ * \brief Links can be activated by clicking or touching the screen.
+ */
+void Draw::event_after(GdkEvent* ev)
+{
+  gdouble ex, ey;
+  Gtk::TextBuffer::iterator iter;
+  int x, y;
+
+  if (ev->type == GDK_BUTTON_RELEASE)
+  {
+    GdkEventButton* event;
+    event = (GdkEventButton*)ev;
+    if (event->button != GDK_BUTTON_PRIMARY)
+      return;
+    ex = event->x;
+    ey = event->y;
+  }
+  else if (ev->type == GDK_TOUCH_END)
+  {
+    GdkEventTouch* event;
+    event = (GdkEventTouch*)ev;
+    ex = event->x;
+    ey = event->y;
+  }
+  else
+    return;
+
+  // Get the textview coordinates and retrieve an iterator
+  window_to_buffer_coords(Gtk::TextWindowType::TEXT_WINDOW_WIDGET, ex, ey, x, y);
+  get_iter_at_location(iter, x, y);
+  // Find the links
+  followLink(iter);
+}
+
+/**
+ * \brief Update the cursor whenever there is a link
+ */
+bool Draw::motion_notify_event(GdkEventMotion* motion_event)
+{
+  int x, y;
+  window_to_buffer_coords(Gtk::TextWindowType::TEXT_WINDOW_WIDGET, motion_event->x, motion_event->y, x, y);
+  this->changeCursor(x, y);
+  return false;
+}
+
+/***
+ * \brief Show tooltip when mouse-hover over URL
+ */
+bool Draw::query_tooltip(int x, int y, bool keyboard_tooltip, const Glib::RefPtr<Gtk::Tooltip>& tooltip)
+{
+  Gtk::TextIter iter;
+  if (keyboard_tooltip)
+  {
+    auto buffer = get_buffer();
+    int offset = buffer->property_cursor_position().get_value();
+    iter = buffer->get_iter_at_offset(offset);
+  }
+  else
+  {
+    int mouseX, mouseY;
+    window_to_buffer_coords(Gtk::TextWindowType::TEXT_WINDOW_WIDGET, x, y, mouseX, mouseY);
+    get_iter_at_location(iter, mouseX, mouseY);
+  }
+  bool found = false;
+  auto tags = iter.get_tags();
+  for (auto const& tag : tags)
+  {
+    char* url = static_cast<char*>(tag->get_data("url"));
+    if (url != 0 && (strlen(url) > 0))
+    {
+      // Show link as tooltip
+      tooltip->set_markup(url);
+      found = true;
+      break;
+    }
+  }
+  if (found)
+  {
+    return true;
+  }
+  else
+  {
+    return false;
+  }
+}
+
+/**
+ * \brief Adapt right-click menu in textview
+ */
+void Draw::populate_popup(Gtk::Menu* menu)
+{
+  auto items = menu->get_children();
+  for (auto* item : items)
+  {
+    Gtk::MenuItem* menuItem = static_cast<Gtk::MenuItem*>(item);
+    Glib::ustring name = menuItem->get_label();
+    if (name.compare("Cu_t") == 0)
+    {
+      menuItem->set_label("Cu_t (Ctrl+X)");
+    }
+    else if (name.compare("_Copy") == 0)
+    {
+      menuItem->set_label("_Copy (Ctrl+C)");
+    }
+    else if (name.compare("_Paste") == 0)
+    {
+      menuItem->set_label("_Paste (Ctrl+V)");
+    }
+    else if (name.compare("_Delete") == 0)
+    {
+      menuItem->set_label("_Delete (Del)");
+    }
+    else if (name.compare("Select _All") == 0)
+    {
+      menuItem->set_label("Select _All (Ctrl+A)");
+    }
+    else if (name.compare("Insert _Emoji") == 0)
+    {
+      item->hide();
+    }
+  }
+  if (this->addViewSourceMenuItem)
+  {
+    Gtk::MenuItem* sourceCodeMenuItem = Gtk::manage(new Gtk::MenuItem("View Source", true));
+    sourceCodeMenuItem->signal_activate().connect(source_code);
+    sourceCodeMenuItem->show();
+    menu->append(*sourceCodeMenuItem);
+  }
+}
+
+/**
+ * \brief Show a message on screen
+ * \param message Headliner
+ * \param details Additional text info
+ */
+void Draw::setMessage(const Glib::ustring& message, const Glib::ustring& details)
+{
+  if (get_editable())
+    this->disableEdit();
+  this->clear();
+
+  this->headingLevel = 1;
+  this->insertText(message);
+  this->headingLevel = 0;
+  this->insertMarkupText("\n\n");
+  this->insertText(details);
+}
+
+/**
+ * \brief Draw homepage
+ */
+void Draw::showStartPage()
+{
+  if (get_editable())
+    this->disableEdit();
+  this->clear();
+
+  this->headingLevel = 1;
+  this->insertText("Welcome to LibreWeb üåçüöÄ");
+  this->headingLevel = 0;
+  this->insertText("\n\n");
+  this->insertMarkupText("Welcome to the decentralized web (also known as web 3.0). Thanks for using LibreWeb!üëç\n\n"
+                         "LibreWeb is a free &amp; open-source decentralized web browser. With LibreWeb can surf the world-wide-web as originally "
+                         "intended, by leveraging IPFS as a decentralized file storage. LibreWeb is also the fastest browser in the world.\n\n"
+                         "The content can be fully written in <i>markdown format</i>, allowing you to easily publish your own site, blog article or "
+                         "e-book. And markdown makes surfing the web very safe.\n"
+                         "This browser has even a <b>built-in editor</b>. Check it out in the menu: <tt>File->New Document</tt>!");
+  this->insertText("\n\nSee an example page hosted on IPFS: ");
+  this->insertLink("Click here for the example page", "ipfs://QmQQQyYm8GcLBEE7H3NMQWfkyfU5yHiT5i1J98gbfDGRuX");
+}
+
+/**
+ * \brief Process AST document (markdown format) and draw the text in the GTK TextView
+ * The cmark_node pointer will be automatically freed for you.
+ * \param rootNode Markdown AST tree that will be displayed on screen
+ */
+void Draw::setDocument(cmark_node* rootNode)
+{
+  if (get_editable())
+    this->disableEdit();
+  this->clear();
+
+  // Loop over AST nodes
+  cmark_event_type ev_type;
+  cmark_iter* iter = cmark_iter_new(rootNode);
+  while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE)
+  {
+    cmark_node* cur = cmark_iter_get_node(iter);
+    try
+    {
+      processNode(cur, ev_type);
+    }
+    catch (const std::runtime_error& error)
+    {
+      std::cerr << "ERROR: Processing node failed, with message: " << error.what() << std::endl;
+      // Continue nevertheless
+    }
+  }
+  // Clean-up the memory
+  cmark_node_free(rootNode);
+}
+
+void Draw::setViewSourceMenuItem(bool isEnabled)
+{
+  this->addViewSourceMenuItem = isEnabled;
+}
+
+/**
+ * \brief Prepare for new document
+ */
+void Draw::newDocument()
+{
+  this->undoPool.clear();
+  this->redoPool.clear();
+  this->clearText();
+
+  enableEdit();
+  grab_focus(); // Claim focus on text view
+}
+
+/**
+ * \brief Retrieve the current text buffer
+ */
+Glib::ustring Draw::getText() const
+{
+  return get_buffer().get()->get_text();
+}
+
+/**
+ * \brief Set text in text buffer (for example plain text)
+ * \param text Text string
+ */
+void Draw::setText(const Glib::ustring& text)
+{
+  get_buffer()->set_text(text);
+}
+
+/**
+ * \brief Clear all text on the screen
+ */
+void Draw::clearText()
+{
+  auto buffer = get_buffer();
+  buffer->erase(buffer->begin(), buffer->end());
+}
+
+/**
+ * Undo action (Ctrl + Z)
+ */
+void Draw::undo()
+{
+  if (get_editable() && (undoPool.size() > 0))
+  {
+    auto undoAction = undoPool.at(undoPool.size() - 1);
+    auto buffer = get_buffer();
+    undoPool.pop_back();
+    if (undoAction.isInsert)
+    {
+      Gtk::TextBuffer::iterator startIter = buffer->get_iter_at_offset(undoAction.beginOffset);
+      Gtk::TextBuffer::iterator endIter = buffer->get_iter_at_offset(undoAction.endOffset);
+      buffer->erase(startIter, endIter);
+      buffer->place_cursor(buffer->get_iter_at_offset(undoAction.beginOffset));
+    }
+    else
+    {
+      Gtk::TextBuffer::iterator startIter = buffer->get_iter_at_offset(undoAction.beginOffset);
+      buffer->insert(startIter, undoAction.text);
+      buffer->place_cursor(buffer->get_iter_at_offset(undoAction.endOffset));
+    }
+    redoPool.push_back(undoAction);
+  }
+}
+
+/**
+ * Redo action (Ctrl + Y)
+ */
+void Draw::redo()
+{
+  if (get_editable() && (redoPool.size() > 0))
+  {
+    auto redoAction = redoPool.at(redoPool.size() - 1);
+    auto buffer = get_buffer();
+    redoPool.pop_back();
+    if (redoAction.isInsert)
+    {
+      Gtk::TextBuffer::iterator startIter = buffer->get_iter_at_offset(redoAction.beginOffset);
+      buffer->insert(startIter, redoAction.text);
+      buffer->place_cursor(buffer->get_iter_at_offset(redoAction.endOffset));
+    }
+    else
+    {
+      Gtk::TextBuffer::iterator startIter = buffer->get_iter_at_offset(redoAction.beginOffset);
+      Gtk::TextBuffer::iterator endIter = buffer->get_iter_at_offset(redoAction.endOffset);
+      buffer->erase(startIter, endIter);
+      buffer->place_cursor(buffer->get_iter_at_offset(redoAction.beginOffset));
+    }
+    undoPool.push_back(redoAction);
+  }
+}
+
+void Draw::cut()
+{
+  if (get_editable())
+  {
+    auto clipboard = get_clipboard("CLIPBOARD");
+    get_buffer()->cut_clipboard(clipboard);
+  }
+  else
+  {
+    auto clipboard = get_clipboard("CLIPBOARD");
+    get_buffer()->copy_clipboard(clipboard);
+  }
+}
+
+void Draw::copy()
+{
+  auto clipboard = get_clipboard("CLIPBOARD");
+  get_buffer()->copy_clipboard(clipboard);
+}
+
+void Draw::paste()
+{
+  if (get_editable())
+  {
+    auto clipboard = get_clipboard("CLIPBOARD");
+    get_buffer()->paste_clipboard(clipboard);
+  }
+}
+
+void Draw::del()
+{
+  if (get_editable())
+  {
+    auto buffer = get_buffer();
+    buffer->begin_user_action();
+    Gtk::TextBuffer::iterator begin, end;
+    if (buffer->get_selection_bounds(begin, end))
+    {
+      buffer->erase(begin, end);
+    }
+    else
+    {
+      ++end;
+      buffer->erase(begin, end);
+    }
+    buffer->end_user_action();
+  }
+}
+
+void Draw::selectAll()
+{
+  auto buffer = get_buffer();
+  buffer->select_range(buffer->begin(), buffer->end());
+}
+
+/*************************************************************
+ * Editor signals calls
+ *************************************************************/
+
+void Draw::make_heading(int headingLevel)
+{
+  Gtk::TextBuffer::iterator start, start_line, end_line, _;
+  auto buffer = get_buffer();
+  buffer->begin_user_action();
+  Glib::ustring heading = Glib::ustring(headingLevel, '#');
+  buffer->get_selection_bounds(start, _);
+
+  start_line = buffer->get_iter_at_line(start.get_line());
+  // Lookup to 12 places further
+  int insertLocation = start_line.get_offset();
+  end_line = buffer->get_iter_at_offset(insertLocation + 12);
+  std::string text = start_line.get_text(end_line);
+  if (!text.empty() && text.starts_with("#"))
+  {
+    std::size_t countHashes = 0;
+    bool hasSpace = false;
+    std::size_t len = text.size();
+    for (Glib::ustring::size_type i = 0; i < len; i++)
+    {
+      if (text[i] == '#')
+        countHashes++;
+      else
+        break;
+    }
+    // Check for next character after the #-signs, is there already a space?
+    if (countHashes < len)
+    {
+      if (text[countHashes] == ' ')
+        hasSpace = true;
+    }
+    Gtk::TextBuffer::iterator delete_iter_end = buffer->get_iter_at_offset(insertLocation + countHashes);
+    // Delete hashes at the beginning on the line
+    buffer->erase(start_line, delete_iter_end);
+    // Buffer is now modified, previous iteraters are now invalid, so get a new iter
+    Gtk::TextBuffer::iterator new_start = buffer->get_iter_at_offset(insertLocation);
+
+    // Finally, insert the new heading (add additional space indeed needed)
+    Glib::ustring insertHeading = (hasSpace) ? heading : heading + " ";
+    buffer->insert(new_start, insertHeading);
+  }
+  else
+  {
+    buffer->insert(start_line, heading + " ");
+  }
+  buffer->end_user_action();
+}
+
+void Draw::make_bold()
+{
+  Gtk::TextBuffer::iterator start, end;
+  auto buffer = get_buffer();
+  buffer->begin_user_action();
+  if (buffer->get_selection_bounds(start, end))
+  {
+    Glib::ustring text = buffer->get_text(start, end);
+    buffer->erase_selection();
+    buffer->insert_at_cursor("**" + text + "**");
+  }
+  else
+  {
+    int insertOffset = buffer->get_insert()->get_iter().get_offset();
+    buffer->insert_at_cursor("****");
+    auto newCursorPos = buffer->get_iter_at_offset(insertOffset + 2);
+    buffer->place_cursor(newCursorPos);
+  }
+  buffer->end_user_action();
+}
+
+void Draw::make_italic()
+{
+  Gtk::TextBuffer::iterator start, end;
+  auto buffer = get_buffer();
+  buffer->begin_user_action();
+  if (buffer->get_selection_bounds(start, end))
+  {
+    Glib::ustring text = buffer->get_text(start, end);
+    buffer->erase_selection();
+    buffer->insert_at_cursor("*" + text + "*");
+  }
+  else
+  {
+    int insertOffset = buffer->get_insert()->get_iter().get_offset();
+    buffer->insert_at_cursor("**");
+    auto newCursorPos = buffer->get_iter_at_offset(insertOffset + 1);
+    buffer->place_cursor(newCursorPos);
+  }
+  buffer->end_user_action();
+}
+
+void Draw::make_strikethrough()
+{
+  Gtk::TextBuffer::iterator start, end;
+  auto buffer = get_buffer();
+  buffer->begin_user_action();
+  if (buffer->get_selection_bounds(start, end))
+  {
+    Glib::ustring text = buffer->get_text(start, end);
+    buffer->erase_selection();
+    buffer->insert_at_cursor("~~" + text + "~~");
+  }
+  else
+  {
+    int insertOffset = buffer->get_insert()->get_iter().get_offset();
+    buffer->insert_at_cursor("~~~~");
+    auto newCursorPos = buffer->get_iter_at_offset(insertOffset + 2);
+    buffer->place_cursor(newCursorPos);
+  }
+  buffer->end_user_action();
+}
+
+void Draw::make_super()
+{
+  Gtk::TextBuffer::iterator start, end;
+  auto buffer = get_buffer();
+  buffer->begin_user_action();
+  if (buffer->get_selection_bounds(start, end))
+  {
+    Glib::ustring text = buffer->get_text(start, end);
+    buffer->erase_selection();
+    buffer->insert_at_cursor("^" + text + "^");
+  }
+  else
+  {
+    int insertOffset = buffer->get_insert()->get_iter().get_offset();
+    buffer->insert_at_cursor("^^");
+    auto newCursorPos = buffer->get_iter_at_offset(insertOffset + 1);
+    buffer->place_cursor(newCursorPos);
+  }
+  buffer->end_user_action();
+}
+
+void Draw::make_sub()
+{
+  Gtk::TextBuffer::iterator start, end;
+  auto buffer = get_buffer();
+  buffer->begin_user_action();
+  if (buffer->get_selection_bounds(start, end))
+  {
+    Glib::ustring text = buffer->get_text(start, end);
+    buffer->erase_selection();
+    buffer->insert_at_cursor("%" + text + "%");
+  }
+  else
+  {
+    int insertOffset = buffer->get_insert()->get_iter().get_offset();
+    buffer->insert_at_cursor("%%");
+    auto newCursorPos = buffer->get_iter_at_offset(insertOffset + 1);
+    buffer->place_cursor(newCursorPos);
+  }
+  buffer->end_user_action();
+}
+
+void Draw::make_quote()
+{
+  Gtk::TextBuffer::iterator start, end;
+  auto buffer = get_buffer();
+  buffer->begin_user_action();
+  if (buffer->get_selection_bounds(start, end))
+  {
+    std::string text = buffer->get_text(start, end);
+    buffer->erase_selection();
+    std::istringstream iss(text);
+    std::string line;
+    while (std::getline(iss, line))
+    {
+      buffer->insert_at_cursor("> " + line + "\n");
+    }
+  }
+  else
+  {
+    buffer->insert_at_cursor("\n> text"); // TODO: only insert new line if there is non before
+  }
+  buffer->end_user_action();
+}
+
+void Draw::insert_link()
+{
+  Gtk::TextBuffer::iterator start, end;
+  auto buffer = get_buffer();
+  buffer->begin_user_action();
+  if (buffer->get_selection_bounds(start, end))
+  {
+    int insertOffset = buffer->get_insert()->get_iter().get_offset();
+    Glib::ustring text = buffer->get_text(start, end);
+    buffer->erase_selection();
+    buffer->insert_at_cursor("[" + text + "](ipfs://url)");
+    auto beginCursorPos = buffer->get_iter_at_offset(insertOffset + text.length() + 10);
+    auto endCursorPos = buffer->get_iter_at_offset(insertOffset + text.length() + 13);
+    buffer->select_range(beginCursorPos, endCursorPos);
+  }
+  else
+  {
+    int insertOffset = buffer->get_insert()->get_iter().get_offset();
+    buffer->insert_at_cursor("[link](ipfs://url)");
+    auto beginCursorPos = buffer->get_iter_at_offset(insertOffset + 14);
+    auto endCursorPos = buffer->get_iter_at_offset(insertOffset + 17);
+    buffer->select_range(beginCursorPos, endCursorPos);
+  }
+  buffer->end_user_action();
+}
+
+void Draw::insert_image()
+{
+  Gtk::TextBuffer::iterator start, end;
+  auto buffer = get_buffer();
+  buffer->begin_user_action();
+  if (buffer->get_selection_bounds(start, end))
+  {
+    Glib::ustring text = buffer->get_text(start, end);
+    buffer->erase_selection();
+    buffer->insert_at_cursor("![](" + text + "]");
+  }
+  else
+  {
+    int insertOffset = buffer->get_insert()->get_iter().get_offset();
+    buffer->insert_at_cursor("![](ipfs://image.jpg)");
+    auto beginCursorPos = buffer->get_iter_at_offset(insertOffset + 11);
+    auto endCursorPos = buffer->get_iter_at_offset(insertOffset + 20);
+    buffer->select_range(beginCursorPos, endCursorPos);
+  }
+  buffer->end_user_action();
+}
+
+// TODO: set_monospace(true)
+void Draw::make_code()
+{
+  Gtk::TextBuffer::iterator start, end;
+  auto buffer = get_buffer();
+  buffer->begin_user_action();
+  if (buffer->get_selection_bounds(start, end))
+  {
+    std::string text = buffer->get_text(start, end);
+    buffer->erase_selection();
+    // Strip begin & end line breaks
+    if (text.starts_with('\n'))
+    {
+      text.erase(0, 1);
+    }
+    if (text.ends_with('\n'))
+    {
+      text.erase(text.size() - 1);
+    }
+    if (text.find('\n') != std::string::npos)
+    {
+      // Insert code block
+      buffer->insert_at_cursor("```\n" + text + "\n```\n");
+    }
+    else
+    {
+      // Insert inline code
+      buffer->insert_at_cursor("`" + text + "`");
+    }
+  }
+  else
+  {
+    int insertOffset = buffer->get_insert()->get_iter().get_offset();
+    buffer->insert_at_cursor("``");
+    auto newCursorPos = buffer->get_iter_at_offset(insertOffset + 1);
+    buffer->place_cursor(newCursorPos);
+  }
+  buffer->end_user_action();
+}
+
+void Draw::insert_bullet_list()
+{
+  Gtk::TextBuffer::iterator start, end;
+  auto buffer = get_buffer();
+  buffer->begin_user_action();
+  bool selected = buffer->get_selection_bounds(start, end);
+  if (selected)
+  {
+    std::string text = buffer->get_text(start, end);
+    buffer->erase_selection();
+    std::istringstream iss(text);
+    std::string line;
+    while (std::getline(iss, line))
+    {
+      // Line already begins with a bullet, remove bullet list item
+      if (line.starts_with("* "))
+        buffer->insert_at_cursor(line.substr(2) + "\n");
+      else if (line.starts_with("*"))
+        buffer->insert_at_cursor(line.substr(1) + "\n");
+      else if (!line.empty() && (line.find_first_not_of(" \t\n\v\f\r") != std::string::npos))
+        buffer->insert_at_cursor("* " + line + "\n");
+    }
+  }
+  else
+  {
+    int curLineNumber = start.get_line();
+    Gtk::TextBuffer::iterator begin_current_line_iter = buffer->get_iter_at_line(curLineNumber);
+    if (start.is_start())
+    {
+      buffer->insert(begin_current_line_iter, "* ");
+    }
+    else
+    {
+      Gtk::TextBuffer::iterator end_current_line_iter, prev_lines_iter;
+      // Get the end of the line iter
+      end_current_line_iter = buffer->get_iter_at_line_offset(curLineNumber, begin_current_line_iter.get_chars_in_line());
+      std::string currentLineText = begin_current_line_iter.get_text(end_current_line_iter);
+      // Get previous line (if possible)
+      prev_lines_iter = buffer->get_iter_at_line(start.get_line() - 1);
+      std::string prevLineText = prev_lines_iter.get_text(start);
+      if (currentLineText.compare("* ") == 0)
+      {
+        // remove empty bullet list
+        buffer->erase(begin_current_line_iter, end_current_line_iter);
+      }
+      else // Insert bullet list
+      {
+        // Was there already a bullet list item? Continue adding bullet item
+        if (currentLineText.starts_with("* "))
+        {
+          // We're still on the current line, new-line is required
+          int insertCharOffset = end_current_line_iter.get_offset();
+          buffer->insert(end_current_line_iter, "\n* ");
+          Gtk::TextBuffer::iterator insert_iter = buffer->get_iter_at_offset(insertCharOffset + 3); // add 3 additional chars
+          buffer->place_cursor(insert_iter);
+        }
+        else if (prevLineText.starts_with("* "))
+        {
+          buffer->insert(begin_current_line_iter, "* ");
+        }
+        else // Insert new bullet list
+        {
+          // Get also the previous two lines (if possible)
+          Gtk::TextBuffer::iterator two_prev_lines_iter = buffer->get_iter_at_line(start.get_line() - 2);
+          std::string prevTwoLinesText = two_prev_lines_iter.get_text(start);
+
+          std::string additionalNewlines;
+          if (prevTwoLinesText.ends_with("\n\n"))
+          {
+            // No additional lines needed
+          }
+          else if (prevLineText.ends_with("\n"))
+          {
+            additionalNewlines = "\n";
+          }
+          else
+          {
+            additionalNewlines = "\n\n";
+          }
+          // Add additional new lines (if needed), before the bullet item
+          buffer->insert_at_cursor(additionalNewlines + "* ");
+        }
+      }
+    }
+  }
+  buffer->end_user_action();
+}
+
+void Draw::insert_numbered_list()
+{
+  Gtk::TextBuffer::iterator start, end;
+  auto buffer = get_buffer();
+  buffer->begin_user_action();
+  bool selected = buffer->get_selection_bounds(start, end);
+  if (selected)
+  {
+    std::string text = buffer->get_text(start, end);
+    buffer->erase_selection();
+    std::istringstream iss(text);
+    std::string line;
+    std::smatch match;
+    int counter = 1;
+    while (std::getline(iss, line))
+    {
+      // Line already begins with a numbering, remove numbered list item
+      if (std::regex_search(line, match, std::regex("^[0-9]+\\. ")))
+        buffer->insert_at_cursor(line.substr(match[0].length()) + "\n");
+      else if (std::regex_search(line, match, std::regex("^[0-9]+\\.")))
+        buffer->insert_at_cursor(line.substr(match[0].length()) + "\n");
+      else if (!line.empty() && (line.find_first_not_of(" \t\n\v\f\r") != std::string::npos))
+      {
+        buffer->insert_at_cursor(std::to_string(counter) + ". " + line + "\n");
+        counter++;
+      }
+    }
+  }
+  else
+  {
+    int curLineNumber = start.get_line();
+    Gtk::TextBuffer::iterator begin_current_line_iter = buffer->get_iter_at_line(curLineNumber);
+    if (start.is_start())
+    {
+      buffer->insert(begin_current_line_iter, "1. ");
+    }
+    else
+    {
+      Gtk::TextBuffer::iterator end_current_line_iter, prev_lines_iter;
+      // Get the end of the line iter
+      end_current_line_iter = buffer->get_iter_at_line_offset(curLineNumber, begin_current_line_iter.get_chars_in_line());
+      std::string currentLineText = begin_current_line_iter.get_text(end_current_line_iter);
+      // Get previous line (if possible)
+      prev_lines_iter = buffer->get_iter_at_line(start.get_line() - 1);
+      std::string prevLineText = prev_lines_iter.get_text(start);
+      if (std::regex_match(currentLineText, std::regex("^[0-9]+\\. ")))
+      {
+        // remove empty numbered list
+        buffer->erase(begin_current_line_iter, end_current_line_iter);
+      }
+      else // Insert numbered list
+      {
+        std::smatch match;
+        // Was there already a numbered list item? Continue adding numbered item
+        if (std::regex_search(currentLineText, match, std::regex("^[0-9]+\\. ")))
+        {
+          try
+          {
+            int number = std::stoi(match[0]);
+            std::string newNumber = std::to_string(++number);
+            int insertCharOffset = end_current_line_iter.get_offset();
+            // We're still on the current line, new-line is required
+            buffer->insert(end_current_line_iter, "\n" + newNumber + ". ");
+            Gtk::TextBuffer::iterator insert_iter =
+                buffer->get_iter_at_offset(insertCharOffset + 3 + newNumber.length()); // add 3 additional chars + number
+            buffer->place_cursor(insert_iter);
+          }
+          catch (std::invalid_argument& error)
+          {
+            // Fall-back
+            int insertCharOffset = end_current_line_iter.get_offset();
+            buffer->insert(end_current_line_iter, "\n1. ");
+            Gtk::TextBuffer::iterator insert_iter = buffer->get_iter_at_offset(insertCharOffset + 3); // add 3 additional chars + number
+            buffer->place_cursor(insert_iter);
+            // Give warning
+            std::cerr << "WARN: Couldn't convert heading to a number?" << std::endl;
+          }
+        }
+        else if (std::regex_search(prevLineText, match, std::regex("^[0-9]+\\. ")))
+        {
+          try
+          {
+            int number = std::stoi(match[0]);
+            std::string newNumber = std::to_string(++number);
+            buffer->insert(begin_current_line_iter, newNumber + ". ");
+          }
+          catch (std::invalid_argument& error)
+          {
+            // Fall-back
+            buffer->insert(begin_current_line_iter, "1. ");
+            // Give warning
+            std::cerr << "WARN: Couldn't convert heading to a number?" << std::endl;
+          }
+        }
+        else // Insert new numbered list
+        {
+          // Get also the previous two lines (if possible)
+          Gtk::TextBuffer::iterator two_prev_lines_iter = buffer->get_iter_at_line(start.get_line() - 2);
+          std::string prevTwoLinesText = two_prev_lines_iter.get_text(start);
+
+          std::string additionalNewlines;
+          if (prevTwoLinesText.ends_with("\n\n"))
+          {
+            // No additional lines needed
+          }
+          else if (prevLineText.ends_with("\n"))
+          {
+            additionalNewlines = "\n";
+          }
+          else
+          {
+            additionalNewlines = "\n\n";
+          }
+          // Add additional new lines (if needed), before the bullet item
+          buffer->insert_at_cursor(additionalNewlines + "1. ");
+        }
+      }
+    }
+  }
+  buffer->end_user_action();
+}
+
+void Draw::make_highlight()
+{
+  Gtk::TextBuffer::iterator start, end;
+  auto buffer = get_buffer();
+  buffer->begin_user_action();
+  if (buffer->get_selection_bounds(start, end))
+  {
+    std::string text = buffer->get_text(start, end);
+    buffer->erase_selection();
+    buffer->insert_at_cursor("==" + text + "==");
+  }
+  else
+  {
+    int insertOffset = buffer->get_insert()->get_iter().get_offset();
+    buffer->insert_at_cursor("====");
+    auto newCursorPos = buffer->get_iter_at_offset(insertOffset + 2);
+    buffer->place_cursor(newCursorPos);
+  }
+  buffer->end_user_action();
+}
+
+void Draw::begin_user_action()
+{
+  this->isUserAction = true;
+}
+
+void Draw::end_user_action()
+{
+  this->isUserAction = false;
+}
+
+/**
+ * Triggered when text gets inserted
+ */
+void Draw::on_insert(const Gtk::TextBuffer::iterator& pos, const Glib::ustring& text, int bytes __attribute__((unused)))
+{
+  if (this->isUserAction)
+  {
+    UndoRedoData undoData = {};
+    undoData.isInsert = true;
+    undoData.beginOffset = pos.get_offset();
+    undoData.endOffset = pos.get_offset() + text.size();
+    undoData.text = text;
+    this->undoPool.push_back(undoData);
+    this->redoPool.clear();
+  }
+}
+
+/**
+ * Triggered when text gets deleted/removed
+ */
+void Draw::on_delete(const Gtk::TextBuffer::iterator& range_start, const Gtk::TextBuffer::iterator& range_end)
+{
+  if (this->isUserAction)
+  {
+    auto text = get_buffer()->get_text(range_start, range_end);
+    UndoRedoData undoData = {};
+    undoData.isInsert = false;
+    undoData.beginOffset = range_start.get_offset();
+    undoData.endOffset = range_end.get_offset();
+    undoData.text = text;
+    this->undoPool.push_back(undoData);
+  }
+}
+
+/************************************************
+ * Private methods
+ ************************************************/
+
+void Draw::enableEdit()
+{
+  set_editable(true);
+  set_cursor_visible(true);
+  auto buffer = get_buffer();
+  this->beginUserActionSignalHandler = buffer->signal_begin_user_action().connect(sigc::mem_fun(this, &Draw::begin_user_action), false);
+  this->endUserActionSignalHandler = buffer->signal_end_user_action().connect(sigc::mem_fun(this, &Draw::end_user_action), false);
+  this->insertTextSignalHandler = buffer->signal_insert().connect(sigc::mem_fun(this, &Draw::on_insert), false);
+  this->deleteTextSignalHandler = buffer->signal_erase().connect(sigc::mem_fun(this, &Draw::on_delete), false);
+}
+
+void Draw::disableEdit()
+{
+  set_editable(false);
+  set_cursor_visible(false);
+  // Disconnect signal handles
+  this->beginUserActionSignalHandler.disconnect();
+  this->endUserActionSignalHandler.disconnect();
+  this->insertTextSignalHandler.disconnect();
+  this->deleteTextSignalHandler.disconnect();
+}
+
+/**
+ * Search for links
+ */
+void Draw::followLink(Gtk::TextBuffer::iterator& iter)
+{
+  auto tags = iter.get_tags();
+  for (auto const& tag : tags)
+  {
+    char* url = static_cast<char*>(tag->get_data("url"));
+    if (url != 0 && (strlen(url) > 0))
+    {
+      // Got to URL
+      middleware.doRequest(url);
+      break;
+    }
+  }
+}
+
+/**
+ * Process and parse each node in the AST
+ */
+void Draw::processNode(cmark_node* node, cmark_event_type ev_type)
+{
+  bool entering = (ev_type == CMARK_EVENT_ENTER);
+
+  // Take care of the markdown extensions
+  if (node->extension)
+  {
+    if (strcmp(node->extension->name, "strikethrough") == 0)
+    {
+      isStrikethrough = entering;
+      return;
+    }
+    else if (strcmp(node->extension->name, "highlight") == 0)
+    {
+      isHighlight = entering;
+      return;
+    }
+    else if (strcmp(node->extension->name, "superscript") == 0)
+    {
+      isSuperscript = entering;
+      return;
+    }
+    else if (strcmp(node->extension->name, "subscript") == 0)
+    {
+      isSubscript = entering;
+      return;
+    }
+  }
+
+  switch (node->type)
+  {
+  case CMARK_NODE_DOCUMENT:
+    if (entering)
+    {
+      // Reset all (better safe than sorry)
+      headingLevel = 0;
+      bulletListLevel = 0;
+      orderedListLevel = 0;
+      listLevel = 0;
+      isOrderedList = false;
+      isBold = false;
+      isItalic = false;
+      isStrikethrough = false;
+      isHighlight = false;
+      isSuperscript = false;
+      isSubscript = false;
+      isQuote = false;
+    }
+    break;
+
+  case CMARK_NODE_BLOCK_QUOTE:
+    isQuote = entering;
+    if (!entering)
+    {
+      // Replace last quote '|'-sign with a normal blank line
+      this->truncateText(2);
+      this->insertMarkupText("\n");
+    }
+    break;
+
+  case CMARK_NODE_LIST:
+  {
+    cmark_list_type listType = node->as.list.list_type;
+
+    if (entering)
+    {
+      listLevel++;
+    }
+    else
+    {
+      listLevel--;
+    }
+    if (listLevel == 0)
+    {
+      // Reset bullet/ordered levels
+      bulletListLevel = 0;
+      orderedListLevel = 0;
+      isOrderedList = false;
+      if (!entering)
+        this->insertMarkupText("\n");
+    }
+    else if (listLevel > 0)
+    {
+      if (entering)
+      {
+        if (listType == cmark_list_type::CMARK_BULLET_LIST)
+        {
+          bulletListLevel++;
+        }
+        else if (listType == cmark_list_type::CMARK_ORDERED_LIST)
+        {
+          orderedListLevel++;
+          // Create the counter (and reset to zero)
+          orderedListCounters[orderedListLevel] = 0;
+        }
+      }
+      else
+      {
+        // Un-indent list level again
+        if (listType == cmark_list_type::CMARK_BULLET_LIST)
+        {
+          bulletListLevel--;
+        }
+        else if (listType == cmark_list_type::CMARK_ORDERED_LIST)
+        {
+          orderedListLevel--;
+        }
+      }
+
+      isOrderedList = (orderedListLevel > 0) && (bulletListLevel <= 0);
+    }
+  }
+  break;
+
+  case CMARK_NODE_ITEM:
+    if (entering)
+    {
+      if (isOrderedList)
+      {
+        // Increasement ordered list counter
+        orderedListCounters[orderedListLevel]++;
+      }
+
+      // Insert tabs & bullet/number
+      if (bulletListLevel > 0)
+      {
+        if (bulletListLevel % 2 == 0)
+        {
+          this->insertText(Glib::ustring(bulletListLevel, '\u0009') + "\u25e6 ");
+        }
+        else
+        {
+          this->insertText(Glib::ustring(bulletListLevel, '\u0009') + "\u2022 ");
+        }
+      }
+      else if (orderedListLevel > 0)
+      {
+        Glib::ustring number;
+        if (orderedListLevel % 2 == 0)
+        {
+          number = Draw::intToRoman(orderedListCounters[orderedListLevel]) + " ";
+        }
+        else
+        {
+          number = std::to_string(orderedListCounters[orderedListLevel]) + ". ";
+        }
+        this->insertText(Glib::ustring(orderedListLevel, '\u0009') + number);
+      }
+    }
+    break;
+
+  case CMARK_NODE_HEADING:
+    if (entering)
+    {
+      headingLevel = node->as.heading.level;
+    }
+    else
+    {
+      // Insert line break after heading
+      this->insertMarkupText("\n\n");
+      headingLevel = 0; // reset
+    }
+    break;
+
+  case CMARK_NODE_CODE_BLOCK:
+  {
+    Glib::ustring code = cmark_node_get_literal(node);
+    Glib::ustring newline = (isQuote) ? "" : "\n";
+    this->insertText(code + newline, "", CodeTypeEnum::CODE_TYPE_CODE_BLOCK);
+  }
+  break;
+
+  case CMARK_NODE_HTML_BLOCK:
+    break;
+
+  case CMARK_NODE_CUSTOM_BLOCK:
+    break;
+
+  case CMARK_NODE_THEMATIC_BREAK:
+  {
+    this->isBold = true;
+    this->insertText("\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015"
+                     "\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\n\n");
+    this->isBold = false;
+  }
+  break;
+
+  case CMARK_NODE_PARAGRAPH:
+    // For listings only insert a single new line
+    if (!entering && (listLevel > 0))
+    {
+      this->insertMarkupText("\n");
+    }
+    // Dealing with paragraphs in quotes
+    else if (entering && isQuote)
+    {
+      this->insertText("\uFF5C ");
+    }
+    else if (!entering && isQuote)
+    {
+      this->insertText("\n\uFF5C\n");
+    }
+    // Normal paragraph, just blank line
+    else if (!entering)
+    {
+      this->insertMarkupText("\n\n");
+    }
+    break;
+
+  case CMARK_NODE_TEXT:
+  {
+    Glib::ustring text = cmark_node_get_literal(node);
+    // URL
+    if (isLink)
+    {
+      this->insertText(text, linkURL);
+      linkURL = "";
+    }
+    // Text (with optional inline formatting)
+    else
+    {
+      this->insertText(text);
+    }
+  }
+  break;
+
+  case CMARK_NODE_LINEBREAK:
+    // Hard brake
+    this->insertMarkupText("\n");
+    break;
+
+  case CMARK_NODE_SOFTBREAK:
+    // only insert space
+    this->insertMarkupText(" ");
+    break;
+
+  case CMARK_NODE_CODE:
+  {
+    Glib::ustring code = cmark_node_get_literal(node);
+    this->insertText(code, "", CodeTypeEnum::CODE_TYPE_INLINE_CODE);
+  }
+  break;
+
+  case CMARK_NODE_HTML_INLINE:
+    break;
+
+  case CMARK_NODE_CUSTOM_INLINE:
+    break;
+
+  case CMARK_NODE_STRONG:
+    isBold = entering;
+    break;
+
+  case CMARK_NODE_EMPH:
+    isItalic = entering;
+    break;
+
+  case CMARK_NODE_LINK:
+    isLink = entering;
+    if (entering)
+    {
+      linkURL = cmark_node_get_url(node);
+    }
+    break;
+
+  case CMARK_NODE_IMAGE:
+    break;
+
+  case CMARK_NODE_FOOTNOTE_REFERENCE:
+    break;
+
+  case CMARK_NODE_FOOTNOTE_DEFINITION:
+    break;
+  default:
+    throw std::runtime_error("Node type '" + Glib::ustring(cmark_node_get_type_string(node)) + "' not found.");
+    break;
+  }
+}
+
+/******************************************************
+ * Helper functions below
+ *****************************************************/
+/**
+ * Encode text string (eg. ampersand-character)
+ * @param[in/out] string
+ */
+void Draw::encodeText(std::string& string) const
+{
+  std::string buffer;
+  buffer.reserve(string.size() + 5);
+  for (size_t pos = 0; pos != string.size(); ++pos)
+  {
+    switch (string[pos])
+    {
+    case '&':
+      buffer.append("&amp;");
+      break;
+    default:
+      buffer.append(&string[pos], 1);
+      break;
+    }
+  }
+  string.swap(buffer);
+}
+
+/**
+ * Insert markup text (markup only works if you first parsed the text, otherwise use the insertMarkupText method)
+ */
+void Draw::insertText(std::string text, const Glib::ustring& url, CodeTypeEnum codeType)
+{
+  std::vector<Glib::ustring> tagNames;
+
+  // Use by reference to replace the string
+  // TODO: For normal text, you want to bring back the '&amp;' to '&' symbol again
+  this->encodeText(text);
+
+  if (isStrikethrough)
+  {
+    tagNames.push_back("strikethrough");
+  }
+  if (isSuperscript)
+  {
+    tagNames.push_back("superscript");
+  }
+  // You can not have superscript & subscript applied together
+  else if (isSubscript)
+  {
+    tagNames.push_back("subscript");
+  }
+  if (isBold)
+  {
+    tagNames.push_back("bold");
+  }
+  if (isItalic)
+  {
+    tagNames.push_back("italic");
+  }
+  if (isHighlight)
+  {
+    tagNames.push_back("highlight");
+  }
+  if (codeType != Draw::CodeTypeEnum::CODE_TYPE_NONE)
+  {
+    tagNames.push_back("code");
+  }
+  if (headingLevel > 0)
+  {
+    switch (headingLevel)
+    {
+    case 1:
+      tagNames.push_back("heading1");
+      break;
+    case 2:
+      tagNames.push_back("heading2");
+      break;
+    case 3:
+      tagNames.push_back("heading3");
+      break;
+    case 4:
+      tagNames.push_back("heading4");
+      break;
+    case 5:
+      tagNames.push_back("heading5");
+      break;
+    case 6:
+      tagNames.push_back("heading6");
+      break;
+    default:
+      break;
+    }
+  }
+  if (isQuote)
+  {
+    tagNames.push_back("quote");
+  }
+
+  // Insert URL
+  if (!url.empty())
+  {
+    this->insertLink(text, url);
+  }
+  // Insert text/heading
+  else
+  {
+    // Special case for code blocks within quote
+    if ((codeType == Draw::CodeTypeEnum::CODE_TYPE_CODE_BLOCK) && isQuote)
+    {
+      std::istringstream iss(text);
+      std::string line;
+      // Add a quote for each new code line
+      while (getline(iss, line))
+      {
+        insertTagText("\uFF5C ", "quote");
+        insertTagText(line + "\n", tagNames);
+      }
+      insertTagText("\uFF5C\n", "quote");
+    }
+    // Special case for heading within quote
+    else if ((headingLevel > 0) && isQuote)
+    {
+      insertTagText("\uFF5C ", "quote");
+      insertTagText(text, tagNames);
+    }
+    // Just insert text/heading the normal way
+    else
+    {
+      insertTagText(text, tagNames);
+    }
+  }
+}
+
+/**
+ * Insert pango text with tags
+ */
+void Draw::insertTagText(const Glib::ustring& text, std::vector<Glib::ustring> const& tagNames)
+{
+  auto buffer = get_buffer();
+  auto endIter = buffer->end();
+  buffer->insert_with_tags_by_name(endIter, text, tagNames);
+}
+
+/**
+ * Insert pango text with a single tag name
+ */
+void Draw::insertTagText(const Glib::ustring& text, const Glib::ustring& tagName)
+{
+  auto buffer = get_buffer();
+  auto endIter = buffer->end();
+  buffer->insert_with_tag(endIter, text, tagName);
+}
+
+/**
+ * Insert markup pango text
+ */
+void Draw::insertMarkupText(const Glib::ustring& text)
+{
+  auto buffer = get_buffer();
+  auto endIter = buffer->end();
+  buffer->insert_markup(endIter, text);
+}
+
+/**
+ * Insert url link
+ */
+void Draw::insertLink(const Glib::ustring& text, const Glib::ustring& url)
+{
+  auto buffer = get_buffer();
+  auto endIter = buffer->end();
+  auto tag = buffer->create_tag();
+  // TODO: Create a tag name with name "url" and reuse tag if possible.
+  tag->property_foreground() = "#569cd6";
+  tag->property_underline() = Pango::Underline::UNDERLINE_SINGLE;
+  tag->set_data("url", g_strdup(url.c_str()));
+  buffer->insert_with_tag(endIter, text, tag);
+}
+
+/**
+ * Remove nr. chars from the end of the text buffer
+ */
+void Draw::truncateText(int charsTruncated)
+{
+  auto buffer = get_buffer();
+  auto endIter = buffer->end();
+  auto beginIter = endIter;
+  beginIter.backward_chars(charsTruncated);
+  buffer->erase(beginIter, endIter);
+}
+
+/**
+ * Clear text-buffer
+ */
+void Draw::clear()
+{
+  auto buffer = get_buffer();
+  auto beginIter = buffer->begin();
+  auto endIter = buffer->end();
+  buffer->erase(beginIter, endIter);
+}
+
+/**
+ *  Looks at all tags covering the position (x, y) in the text view,
+ * and if one of them is a link, change the cursor to the "hands" cursor
+ * typically used by web browsers.
+ */
+void Draw::changeCursor(int x, int y)
+{
+  Gtk::TextBuffer::iterator iter;
+  bool hovering = false;
+
+  get_iter_at_location(iter, x, y);
+  auto tags = iter.get_tags();
+  for (auto const& tag : tags)
+  {
+    char* url = static_cast<char*>(tag->get_data("url"));
+    if (url != 0 && (strlen(url) > 0))
+    {
+      // Link
+      hovering = true;
+      break;
+    }
+  }
+
+  if (hovering != hovingOverLink)
+  {
+    hovingOverLink = hovering;
+    auto window = get_window(Gtk::TextWindowType::TEXT_WINDOW_TEXT);
+    if (hovingOverLink)
+      window->set_cursor(linkCursor);
+    else
+      window->set_cursor(normalCursor);
+  }
+}
+
+/**
+ * Convert number to roman numerals
+ */
+Glib::ustring Draw::intToRoman(int num)
+{
+  static const int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
+  static const Glib::ustring numerals[] = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
+  Glib::ustring res;
+  for (int i = 0; i < 13; ++i)
+  {
+    while (num >= values[i])
+    {
+      num -= values[i];
+      res += numerals[i];
+    }
+  }
+  return res;
+}
diff --git a/src/draw.h b/src/draw.h
new file mode 100644
index 00000000..70c85143
--- /dev/null
+++ b/src/draw.h
@@ -0,0 +1,132 @@
+#ifndef DRAW_H
+#define DRAW_H
+
+#include <cmark-gfm.h>
+#include <gdkmm/cursor.h>
+#include <gtkmm/menu.h>
+#include <gtkmm/textview.h>
+#include <gtkmm/tooltip.h>
+#include <pangomm/layout.h>
+
+class Middleware;
+
+/**
+ * \struct UndoRedoData
+ * \brief Data structure for undo/redo text
+ */
+struct UndoRedoData
+{
+  bool isInsert;
+  Glib::ustring text;
+  int beginOffset;
+  int endOffset;
+};
+
+/**
+ * \class Draw
+ * \brief Draw text area (GTK TextView), where the document content will be displayed or used a text editor
+ */
+class Draw : public Gtk::TextView
+{
+public:
+  sigc::signal<void> source_code;
+  enum CodeTypeEnum
+  {
+    CODE_TYPE_NONE = 0,
+    CODE_TYPE_INLINE_CODE,
+    CODE_TYPE_CODE_BLOCK
+  };
+
+  explicit Draw(Middleware& middleware);
+  void setMessage(const Glib::ustring& message, const Glib::ustring& details = "");
+  void showStartPage();
+  void setDocument(cmark_node* rootNode);
+  void setViewSourceMenuItem(bool isEnabled);
+  void newDocument();
+  Glib::ustring getText() const;
+  void setText(const Glib::ustring& text);
+  void clearText();
+  void undo();
+  void redo();
+  void cut();
+  void copy();
+  void paste();
+  void del();
+  void selectAll();
+
+  // Signals editor calls
+  void make_heading(int headingLevel);
+  void make_bold();
+  void make_italic();
+  void make_strikethrough();
+  void make_super();
+  void make_sub();
+  void make_quote();
+  void insert_link();
+  void insert_image();
+  void make_code();
+  void insert_bullet_list();
+  void insert_numbered_list();
+  void make_highlight();
+  void begin_user_action();
+  void end_user_action();
+  void on_insert(const Gtk::TextBuffer::iterator& pos, const Glib::ustring& text, int bytes);
+  void on_delete(const Gtk::TextBuffer::iterator& range_start, const Gtk::TextBuffer::iterator& range_end);
+
+protected:
+  // Signals
+  void event_after(GdkEvent* ev);
+  bool motion_notify_event(GdkEventMotion* motion_event);
+  bool query_tooltip(int x, int y, bool keyboard_tooltip, const Glib::RefPtr<Gtk::Tooltip>& tooltip);
+  void populate_popup(Gtk::Menu* menu);
+
+private:
+  Middleware& middleware;
+  GtkTextBuffer* buffer;
+  bool addViewSourceMenuItem;
+  int headingLevel;
+  int listLevel;
+  bool isBold;
+  bool isItalic;
+  bool isStrikethrough;
+  bool isHighlight;
+  bool isSuperscript;
+  bool isSubscript;
+  bool isQuote;
+  int bulletListLevel;
+  int orderedListLevel;
+  bool isOrderedList;
+  bool isLink;
+  Glib::ustring linkURL;
+  std::map<int, int> orderedListCounters;
+  Glib::RefPtr<Gdk::Cursor> normalCursor;
+  Glib::RefPtr<Gdk::Cursor> linkCursor;
+  Glib::RefPtr<Gdk::Cursor> textCursor;
+  bool hovingOverLink;
+  bool isUserAction;
+
+  std::vector<UndoRedoData> undoPool;
+  std::vector<UndoRedoData> redoPool;
+  sigc::connection beginUserActionSignalHandler;
+  sigc::connection endUserActionSignalHandler;
+  sigc::connection insertTextSignalHandler;
+  sigc::connection deleteTextSignalHandler;
+
+  void addTags();
+  void enableEdit();
+  void disableEdit();
+  void followLink(Gtk::TextBuffer::iterator& iter);
+  void processNode(cmark_node* node, cmark_event_type ev_type);
+  void encodeText(std::string& string) const;
+  void insertText(std::string text, const Glib::ustring& url = "", CodeTypeEnum codeType = CodeTypeEnum::CODE_TYPE_NONE);
+  void insertTagText(const Glib::ustring& text, std::vector<Glib::ustring> const& tagNames);
+  void insertTagText(const Glib::ustring& text, const Glib::ustring& tagName);
+  void insertMarkupText(const Glib::ustring& text);
+  void insertLink(const Glib::ustring& text, const Glib::ustring& url);
+  void truncateText(int charsTruncated);
+  void clear();
+  void changeCursor(int x, int y);
+  static Glib::ustring intToRoman(int num);
+};
+
+#endif
\ No newline at end of file
diff --git a/src/file.cc b/src/file.cc
new file mode 100644
index 00000000..48032ecd
--- /dev/null
+++ b/src/file.cc
@@ -0,0 +1,61 @@
+#include "file.h"
+#include <fstream>
+#include <ipfs/client.h>
+#include <stdexcept>
+
+#ifdef LEGACY_CXX
+#include <experimental/filesystem>
+namespace n_fs = ::std::experimental::filesystem;
+#else
+#include <filesystem>
+namespace n_fs = ::std::filesystem;
+#endif
+
+/**
+ * \brief Read file from disk
+ * \param path File path location to read the file from
+ * \throw std::runtime_error exception when file is not found (or not a regular file),
+ *        or std::ios_base::failure when file can't be read
+ * \return Contents as string
+ */
+std::string File::read(const std::string& path)
+{
+  if (n_fs::exists(path) && n_fs::is_regular_file(path))
+  {
+    std::ifstream inFile;
+    inFile.open(path, std::ifstream::in);
+
+    std::stringstream strStream;
+    strStream << inFile.rdbuf();
+    return strStream.str();
+  }
+  else
+  {
+    // File doesn't exists or isn't a file
+    throw std::runtime_error("File does not exists or isn't a regular file.");
+  }
+}
+
+/**
+ * \brief Write file to disk
+ * \param path File path location for storing the file
+ * \param content Content that needs to be written to file
+ * \throw std::ios_base::failure when file can't be written to
+ */
+void File::write(const std::string& path, const std::string& content)
+{
+  std::ofstream file;
+  file.open(path.c_str());
+  file << content;
+  file.close();
+}
+
+/**
+ * \brief Retrieve filename from file path
+ * \param path Full path
+ * \return filename
+ */
+std::string File::getFilename(const std::string& path)
+{
+  return n_fs::path(path).filename().string();
+}
diff --git a/src/file.h b/src/file.h
new file mode 100644
index 00000000..4a8856c8
--- /dev/null
+++ b/src/file.h
@@ -0,0 +1,17 @@
+#ifndef FILE_H
+#define FILE_H
+
+#include <string>
+
+/**
+ * \class File
+ * \brief Read/write markdown files from disk and retrieve filename from path
+ */
+class File
+{
+public:
+  static std::string read(const std::string& path);
+  static void write(const std::string& path, const std::string& content);
+  static std::string getFilename(const std::string& path);
+};
+#endif
\ No newline at end of file
diff --git a/src/ipfs-daemon.cc b/src/ipfs-daemon.cc
new file mode 100644
index 00000000..9de6a8ae
--- /dev/null
+++ b/src/ipfs-daemon.cc
@@ -0,0 +1,243 @@
+#include "ipfs-daemon.h"
+
+#include <glibmm/fileutils.h>
+#include <glibmm/main.h>
+#include <glibmm/miscutils.h>
+#include <glibmm/shell.h>
+#include <iostream>
+#include <unistd.h>
+#include <whereami.h>
+
+#ifdef LEGACY_CXX
+#include <experimental/filesystem>
+namespace n_fs = ::std::experimental::filesystem;
+#else
+#include <filesystem>
+namespace n_fs = ::std::filesystem;
+#endif
+#ifdef _WIN32
+#include <windows.h>
+#endif
+
+/**
+ * \brief Spawn the IPFS daemon in an async manner using Glib. If needed under Linux (under Windows, it tries to start
+ * IPFS anyway).
+ */
+void IPFSDaemon::spawn()
+{
+  // Check for PID under UNIX
+  int daemonPID = IPFSDaemon::getExistingPID();
+  // Is IPFS Daemon already running?
+  if (daemonPID > 0)
+  {
+    std::cout << "INFO: IPFS Daemon is already running. Do not start another IPFS process." << std::endl;
+  }
+  else
+  {
+    std::string command = IPFSDaemon::locateIPFSBinary();
+    if (n_fs::exists(command))
+    {
+      std::cout << "INFO: Starting IPFS Daemon: " << command << "..." << std::endl;
+      try
+      {
+        // IPFS command
+        std::vector<std::string> argv;
+        argv.push_back(command);
+        argv.push_back("daemon");
+        argv.push_back("--init");
+        argv.push_back("--migrate");
+
+        // Spawn flags
+        // Send stdout & stderr to /dev/null. Don't reaped the child automatically
+        Glib::SpawnFlags flags =
+            Glib::SPAWN_STDOUT_TO_DEV_NULL | Glib::SPAWN_STDERR_TO_DEV_NULL | Glib::SPAWN_DO_NOT_REAP_CHILD | Glib::SPAWN_SEARCH_PATH;
+
+        // Start IPFS using spawn_async_with_pipes,
+        // so we also retrieve stdout & stderr.
+        // spawn_async() is also fine
+        Glib::spawn_async(workingDir, argv, flags, Glib::SlotSpawnChildSetup(), &pid);
+
+        if (childWatchConnectionHandler.connected())
+          childWatchConnectionHandler.disconnect();
+
+        childWatchConnectionHandler = Glib::signal_child_watch().connect(sigc::mem_fun(*this, &IPFSDaemon::child_watch_exit), pid);
+      }
+      catch (Glib::SpawnError& error)
+      {
+        std::cerr << "ERROR: IPFS process could not be started. Reason: " << error.what() << std::endl;
+      }
+      catch (Glib::ShellError& error)
+      {
+        std::cerr << "ERROR: IPFS process could not be started. Reason: " << error.what() << std::endl;
+      }
+    }
+    else
+    {
+      std::cerr << "ERROR: IPFS Daemon is not found. IPFS will most likely not work!" << std::endl;
+    }
+  }
+}
+
+/**
+ * \brief Stop process manually
+ */
+void IPFSDaemon::stop()
+{
+  if (pid != 0)
+    Glib::spawn_close_pid(pid);
+  childWatchConnectionHandler.disconnect();
+}
+
+/**
+ * \brief Exit signal handler for the process.
+ * Emits the exited signal with the status code.
+ *
+ * Avoid using this-> calls, this will lead to segmention faults
+ */
+void IPFSDaemon::child_watch_exit(Glib::Pid pid, int childStatus)
+{
+  std::cout << "WARN: IPFS Daemon exited, PID: " << pid << ", with status code: " << childStatus << std::endl;
+  Glib::spawn_close_pid(pid);
+  // Emit exit signal with status code
+  exited.emit(childStatus);
+}
+
+/**
+ * \brief Get Process ID (PID)
+ * \return PID
+ */
+int IPFSDaemon::getPID() const
+{
+  if (pid == 0)
+    return 0;
+#ifdef _WIN32
+  return GetProcessId(pid);
+#else
+  return pid;
+#endif
+}
+
+/**
+ * \brief Try to locate the ipfs binary path (IPFS go server)
+ * \return full path to the ipfs binary, empty string when not found
+ */
+std::string IPFSDaemon::locateIPFSBinary()
+{
+  std::string ipfsBinaryName = "ipfs";
+  std::string currentExecutablePath;
+#ifdef _WIN32
+  ipfsBinaryName += ".exe";
+#endif
+  // Use the current executable directory (bin folder), to locate the go-ipfs binary (for both Linux and Windows)
+  char* path = NULL;
+  int length, dirnameLength;
+  length = wai_getExecutablePath(NULL, 0, &dirnameLength);
+  if (length > 0)
+  {
+    path = (char*)malloc(length + 1);
+    if (!path)
+    {
+      std::cerr << "ERROR: Couldn't create executable path." << std::endl;
+    }
+    else
+    {
+      wai_getExecutablePath(path, length, &dirnameLength);
+      path[dirnameLength] = '\0';
+      currentExecutablePath = std::string(path);
+      free(path);
+    }
+  }
+  std::string ipfs_binary_path = Glib::build_filename(currentExecutablePath, ipfsBinaryName);
+
+  // When working directory is the build/bin folder (relative path), during the build (when package is not installed
+  // yet)
+  std::string ipfs_binary_path_dev = Glib::build_filename(n_fs::current_path().string(), "..", "..", "go-ipfs", ipfsBinaryName);
+  if (Glib::file_test(ipfs_binary_path, Glib::FileTest::FILE_TEST_IS_EXECUTABLE))
+  {
+    return ipfs_binary_path;
+  }
+  else if (Glib::file_test(ipfs_binary_path_dev, Glib::FileTest::FILE_TEST_IS_EXECUTABLE))
+  {
+    return ipfs_binary_path_dev;
+  }
+  else
+  {
+    return "";
+  }
+}
+
+/**
+ * \brief Retrieve existing running IPFS PID for **UNIX only** (zero if non-existent)
+ * \return Process ID (0 of non-existent)
+ */
+int IPFSDaemon::getExistingPID()
+{
+  int pid = 0;
+#ifdef __linux__
+  int exitCode = -3;
+  std::string stdout;
+  try
+  {
+    Glib::spawn_command_line_sync("pidof -s ipfs", &stdout, nullptr, &exitCode);
+    // Process exists
+    if (exitCode == 0)
+    {
+      pid = std::stoi(stdout);
+    }
+  }
+  catch (Glib::SpawnError& error)
+  {
+    std::cerr << "ERROR: Could not check of running IPFS process. Reason: " << error.what() << std::endl;
+  }
+  catch (Glib::ShellError& error)
+  {
+    std::cerr << "ERROR: Could not check of running IPFS process. Reason: " << error.what() << std::endl;
+  }
+#endif
+  return pid;
+}
+
+/**
+ * Determine if we need to kill any running IPFS process (UNIX only)
+ *
+ * return - true if it needs to be terminated, otherwise false
+ *
+ * Should we even want this? We were using:
+
+bool IPFSDaemon::shouldProcessTerminated()
+{
+#ifdef __linux__
+    char pathbuf[1024];
+    memset(pathbuf, 0, sizeof(pathbuf));
+    std::string path = "/proc/" + std::to_string(pid) + "/exe";
+    if (readlink(path.c_str(), pathbuf, sizeof(pathbuf) - 1) > 0)
+    {
+        char beginPath[] = "/usr/share/libreweb-browser";
+        // If the begin path does not match (!= 0), return true,
+        // meaning the process will be killed.
+        bool shouldKill = (strncmp(pathbuf, beginPath, strlen(beginPath)) != 0);
+
+        // Also check the IPFS version
+        try {
+            std::string expectedString = "version 0.11.0";
+            std::string stdout;
+            Glib::spawn_command_line_sync(path + " version", &stdout);
+            // Current running IPFS version matches our IPFS version, keep process running afterall
+            if (stdout.find(expectedString) != std::string::npos)
+            {
+                shouldKill = false;
+            }
+        }
+        catch (Glib::SpawnError &error)
+        {
+            std::cerr << "ERROR: Could not check IPFS version. Reason: " << error.what() << std::endl;
+        }
+        catch (Glib::ShellError &error)
+        {
+            std::cerr << "ERROR: Could not check IPFS version. Reason: " << error.what() << std::endl;
+        }
+        return shouldKill;
+    }
+#endif
+    return false; // fallback; do not kill
+}*/
\ No newline at end of file
diff --git a/src/ipfs-daemon.h b/src/ipfs-daemon.h
new file mode 100644
index 00000000..fbb17e6f
--- /dev/null
+++ b/src/ipfs-daemon.h
@@ -0,0 +1,32 @@
+#ifndef IPFS_DAEMON_H
+#define IPFS_DAEMON_H
+
+#include <glibmm/spawn.h>
+#include <string>
+
+/**
+ * \class IPFSDaemon
+ * \brief IPFS Daemon process class to start/stop IPFS daemon as a child process
+ */
+class IPFSDaemon
+{
+public:
+  void spawn();
+  void stop();
+  int getPID() const;
+  sigc::signal<void, int> exited;
+
+protected:
+  // Signals
+  void child_watch_exit(Glib::Pid pid, int childStatus);
+
+private:
+  std::string workingDir = ""; // cwd
+  Glib::Pid pid = 0;
+  sigc::connection childWatchConnectionHandler;
+
+  static std::string locateIPFSBinary();
+  static int getExistingPID();
+  // bool shouldProcessTerminated();
+};
+#endif
\ No newline at end of file
diff --git a/src/ipfs.cc b/src/ipfs.cc
new file mode 100644
index 00000000..ddba7a26
--- /dev/null
+++ b/src/ipfs.cc
@@ -0,0 +1,147 @@
+#include "ipfs.h"
+
+/**
+ * \brief IPFS Contructor, connect to IPFS
+ * \param host IPFS host (eg. localhost)
+ * \param port IPFS port number (5001)
+ * \param timeout IPFS time-out (which is a string, eg. "6s" for 6 seconds)
+ */
+IPFS::IPFS(const std::string& host, int port, const std::string& timeout)
+    : host(host),
+      port(port),
+      timeout(timeout),
+      client(this->host, this->port, this->timeout)
+{
+}
+
+/**
+ * \brief Get the number of IPFS peers. Does not throw errors.
+ * \return number of peers as size_t
+ */
+std::size_t IPFS::getNrPeers()
+{
+  ipfs::Json peers;
+  client.SwarmPeers(&peers);
+  return peers["Peers"].size();
+}
+
+/**
+ * \brief Retrieve your IPFS client ID. Does not throw errors.
+ * \return ID as string
+ */
+std::string IPFS::getClientID()
+{
+  ipfs::Json id;
+  client.Id(&id);
+  return id["ID"];
+}
+
+/**
+ * \brief Retrieve your IPFS Public Key. Does not throw errors.
+ * \return Public key string
+ */
+std::string IPFS::getClientPublicKey()
+{
+  ipfs::Json id;
+  client.Id(&id);
+  return id["PublicKey"];
+}
+
+/**
+ * \brief Retrieve the Go IPFS daemon version. Does not throw errors.
+ * \return Version string
+ */
+std::string IPFS::getVersion()
+{
+  ipfs::Json version;
+  client.Version(&version);
+  return version["Version"];
+}
+
+/**
+ * \brief Get the number of IPFS peers. Does not throw errors.
+ * \return Map with bandwidth information (with keys: 'in' and 'out')
+ */
+std::map<std::string, float> IPFS::getBandwidthRates()
+{
+  std::map<std::string, float> bandwidthRates;
+  ipfs::Json bandwidth_info;
+  client.StatsBw(&bandwidth_info);
+  float in = bandwidth_info["RateIn"];
+  float out = bandwidth_info["RateOut"];
+  bandwidthRates.insert(std::pair<std::string, float>("in", in));
+  bandwidthRates.insert(std::pair<std::string, float>("out", out));
+  return bandwidthRates;
+}
+
+/**
+ * \brief Get the stats of the current Repo. Does not throw errors.
+ * \return Map with repo stats (with keys: 'repo-size' and 'path')
+ */
+std::map<std::string, std::variant<int, std::string>> IPFS::getRepoStats()
+{
+  std::map<std::string, std::variant<int, std::string>> repoStats;
+  ipfs::Json repo_stats;
+  client.StatsRepo(&repo_stats);
+  int repoSize = (int)repo_stats["RepoSize"] / 1000000; // Convert from bytes to MB
+  std::string repoPath = repo_stats["RepoPath"];
+  repoStats.insert(std::pair<std::string, int>("repo-size", repoSize));
+  repoStats.insert(std::pair<std::string, std::string>("path", repoPath));
+  return repoStats;
+}
+
+/**
+ * \brief Fetch file from IFPS network
+ * \param path File path
+ * \param contents File contents as iostream
+ * \throw std::runtime_error when there is a
+ * connection-time/something goes wrong while trying to get the file
+ */
+void IPFS::fetch(const std::string& path, std::iostream* contents)
+{
+  client.FilesGet(path, contents);
+}
+
+/**
+ * \brief Add a file to IPFS network
+ * \param path File path where the file could be stored in IPFS (like putting a file inside a directory within IPFS)
+ * \param content Content that needs to be written to the IPFS network
+ * \throw std::runtime_error when there is a connection-time/something goes wrong while adding the file
+ * \return IPFS content-addressed identifier (CID) hash
+ */
+std::string IPFS::add(const std::string& path, const std::string& content)
+{
+  ipfs::Json result;
+  std::string hash;
+  // Publish a single file
+  client.FilesAdd({{path, ipfs::http::FileUpload::Type::kFileContents, content}}, &result);
+  if (result.is_array() && result.size() > 0)
+  {
+    for (const auto& files : result.items())
+    {
+      hash = files.value()["hash"];
+      break;
+    }
+  }
+  else
+  {
+    throw std::runtime_error("File is not added, result is incorrect.");
+  }
+  return hash;
+}
+
+/**
+ * Abort the request abruptly. Used for stopping the thread.
+ */
+void IPFS::abort()
+{
+  client.Abort();
+}
+
+/**
+ * Reset the state, to allow for new API IPFS requests. Used after the thread.join() and abort() call.
+ */
+void IPFS::reset()
+{
+  client.Reset();
+}
diff --git a/src/ipfs.h b/src/ipfs.h
new file mode 100644
index 00000000..5de215c4
--- /dev/null
+++ b/src/ipfs.h
@@ -0,0 +1,35 @@
+#ifndef IPFS_H
+#define IPFS_H
+
+#include "ipfs/client.h"
+#include <iostream>
+#include <map>
+#include <string>
+#include <variant>
+
+/**
+ * \class IPFS
+ * \brief IPFS Abstraction Layer to the C++ IPFS HTTP Client
+ */
+class IPFS
+{
+public:
+  explicit IPFS(const std::string& host, int port, const std::string& timeout);
+  std::size_t getNrPeers();
+  std::string getClientID();
+  std::string getClientPublicKey();
+  std::string getVersion();
+  std::map<std::string, float> getBandwidthRates();
+  std::map<std::string, std::variant<int, std::string>> getRepoStats();
+  void fetch(const std::string& path, std::iostream* contents);
+  std::string add(const std::string& path, const std::string& content);
+  void abort();
+  void reset();
+
+private:
+  std::string host;    /* IPFS host name */
+  int port;            /* IFPS port number */
+  std::string timeout; /* IPFS timeout (eg. 6s) */
+  ipfs::Client client; /* IPFS Client object */
+};
+#endif
\ No newline at end of file
diff --git a/src/main.cc b/src/main.cc
new file mode 100644
index 00000000..4694fb8a
--- /dev/null
+++ b/src/main.cc
@@ -0,0 +1,64 @@
+#include "ipfs-daemon.h"
+#include "mainwindow.h"
+#include "option-group.h"
+#include "project_config.h"
+
+#include <gtkmm/application.h>
+#include <iomanip>
+#include <iostream>
+#include <sys/types.h>
+#include <unistd.h>
+
+/**
+ * \brief Entry point of the app
+ */
+int main(int argc, char* argv[])
+{
+  // Set the command-line parameters option settings
+  Glib::OptionContext context("LibreWeb Browser - Decentralized Web Browser");
+  OptionGroup group;
+  Glib::ustring defaultTimeout = group.timeout;
+  context.set_main_group(group);
+
+  // Create the GTK application
+  auto app = Gtk::Application::create();
+  app->set_flags(Gio::ApplicationFlags::APPLICATION_NON_UNIQUE);
+
+  // Parse the context
+  try
+  {
+    context.parse(argc, argv);
+    if (group.version)
+    {
+      std::cout << "LibreWeb Browser " << PROJECT_VER << std::endl;
+      exit(EXIT_SUCCESS);
+    }
+  }
+  catch (const Glib::Error& error)
+  {
+    std::cerr << "ERROR: Parse failure: " << error.what() << std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+  // The default is to start the IPFS Daemon
+  if (group.disableIPFSDaemon)
+  {
+    std::cout << "WARN: You disabled the IPFS Daemon from starting-up "
+                 "(you are using: -d/--disable-ipfs-daemon)."
+              << std::endl;
+  }
+  else
+  {
+    IPFSDaemon ipfsDaemon;
+    ipfsDaemon.spawn();
+  }
+
+  if (group.timeout.compare(defaultTimeout) != 0)
+  {
+    std::cout << "WARN: You changed the time-out value. Please, be sure you know what you're doing." << std::endl;
+  }
+
+  // Run the GTK window in the main thread
+  MainWindow window(group.timeout);
+  return app->run(window);
+}
diff --git a/src/mainwindow.cc b/src/mainwindow.cc
new file mode 100644
index 00000000..c9d2095b
--- /dev/null
+++ b/src/mainwindow.cc
@@ -0,0 +1,2015 @@
+#include "mainwindow.h"
+
+#include "menu.h"
+#include "project_config.h"
+#include <gdk-pixbuf/gdk-pixbuf.h>
+#include <giomm/file.h>
+#include <giomm/notification.h>
+#include <giomm/settingsschemasource.h>
+#include <giomm/themedicon.h>
+#include <glibmm/convert.h>
+#include <glibmm/fileutils.h>
+#include <glibmm/miscutils.h>
+#include <gtkmm/image.h>
+#include <gtkmm/listboxrow.h>
+#include <gtkmm/menuitem.h>
+#include <gtkmm/settings.h>
+#include <iostream>
+#include <nlohmann/json.hpp>
+#include <whereami.h>
+
+MainWindow::MainWindow(const std::string& timeout)
+    : m_accelGroup(Gtk::AccelGroup::create()),
+      m_settings(),
+      m_brightnessAdjustment(Gtk::Adjustment::create(1.0, 0.0, 1.0, 0.05, 0.1)),
+      m_spacingAdjustment(Gtk::Adjustment::create(0, -10, 10, 1, 2)),
+      m_marginsAdjustment(Gtk::Adjustment::create(20, 0, 1000, 10, 20)),
+      m_indentAdjustment(Gtk::Adjustment::create(0, 0, 1000, 5, 10)),
+      m_drawCSSProvider(Gtk::CssProvider::create()),
+      m_menu(m_accelGroup),
+      m_draw_main(middleware_),
+      m_draw_secondary(middleware_),
+      m_about(*this),
+      m_vbox(Gtk::ORIENTATION_VERTICAL, 0),
+      m_vboxSearch(Gtk::ORIENTATION_VERTICAL),
+      m_vboxStatus(Gtk::ORIENTATION_VERTICAL),
+      m_vboxSettings(Gtk::ORIENTATION_VERTICAL),
+      m_vboxIconTheme(Gtk::ORIENTATION_VERTICAL),
+      m_searchMatchCase("Match _Case", true),
+      m_networkHeadingLabel("IPFS Network"),
+      m_networkRateHeadingLabel("Network rate"),
+      m_connectivityLabel("Status:"),
+      m_peersLabel("Connected peers:"),
+      m_repoSizeLabel("Repo size:"),
+      m_repoPathLabel("Repo path:"),
+      m_ipfsVersionLabel("IPFS version:"),
+      m_networkIncomingLabel("Incoming"),
+      m_networkOutcomingLabel("Outcoming"),
+      m_networkKiloBytesLabel("Kilobytes/s"),
+      m_fontLabel("Font"),
+      m_spacingLabel("Spacing"),
+      m_marginsLabel("Margins"),
+      m_indentLabel("Indent"),
+      m_themeLabel("Dark Theme"),
+      m_iconThemeLabel("Active Theme"),
+      // Private members
+      middleware_(*this, timeout),
+      appName_("LibreWeb Browser"),
+      useCurrentGTKIconTheme_(false), // Use LibreWeb icon theme or the GTK icons
+      iconTheme_("flat"),             // Default is flat built-in theme
+      iconSize_(18),
+      fontFamily_("Sans"),
+      defaultFontSize_(10),
+      currentFontSize_(10),
+      fontSpacing_(0),
+      brightnessScale_(1.0),
+      useDarkTheme_(false),
+      currentHistoryIndex_(0)
+{
+  set_title(appName_);
+  set_default_size(1000, 800);
+  set_position(Gtk::WIN_POS_CENTER);
+  add_accel_group(m_accelGroup);
+
+  loadStoredSettings();
+  loadIcons();
+  initButtons();
+  setTheme();
+  initSearchPopover();
+  initStatusPopover();
+  initSettingsPopover();
+  initSignals();
+
+  // Add custom CSS Provider to draw textviews
+  auto styleMain = m_draw_main.get_style_context();
+  auto styleSecondary = m_draw_secondary.get_style_context();
+  styleMain->add_provider(m_drawCSSProvider, GTK_STYLE_PROVIDER_PRIORITY_USER);
+  styleSecondary->add_provider(m_drawCSSProvider, GTK_STYLE_PROVIDER_PRIORITY_USER);
+  // Load the default font family and font size
+  updateCSS();
+
+  // Browser text main drawing area
+  m_scrolledWindowMain.add(m_draw_main);
+  m_scrolledWindowMain.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
+  // Secondary drawing area
+  m_draw_secondary.setViewSourceMenuItem(false);
+  m_scrolledWindowSecondary.add(m_draw_secondary);
+  m_scrolledWindowSecondary.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
+
+  m_paned.pack1(m_scrolledWindowMain, true, false);
+  m_paned.pack2(m_scrolledWindowSecondary, true, true);
+
+  m_vbox.pack_start(m_menu, false, false, 0);
+  m_vbox.pack_start(m_hboxBrowserToolbar, false, false, 6);
+  m_vbox.pack_start(m_hboxStandardEditorToolbar, false, false, 6);
+  m_vbox.pack_start(m_hboxFormattingEditorToolbar, false, false, 6);
+  m_vbox.pack_start(m_paned, true, true, 0);
+
+  add(m_vbox);
+  show_all_children();
+
+  // Hide by default the replace entry, editor box & secondary text view
+  m_searchReplaceEntry.hide();
+  m_hboxStandardEditorToolbar.hide();
+  m_hboxFormattingEditorToolbar.hide();
+  m_scrolledWindowSecondary.hide();
+
+  // Grap focus to input field by default
+  m_addressBar.grab_focus();
+
+// Show homepage if debugging is disabled
+#ifdef NDEBUG
+  go_home();
+#else
+  std::cout << "INFO: Running as Debug mode, opening test.md." << std::endl;
+  // Load test file when developing
+  middleware_.doRequest("file://../../test.md");
+#endif
+}
+
+/**
+ * \brief Called before the requests begins.
+ * \param path File path (on disk or IPFS) that needs to be processed.
+ * \param title Application title
+ * \param isSetAddressBar If true update the address bar with the file path
+ * \param isHistoryRequest Set to true if this is an history request call: back/forward
+ * \param isDisableEditor If true the editor will be disabled if needed
+ */
+void MainWindow::preRequest(const std::string& path, const std::string& title, bool isSetAddressBar, bool isHistoryRequest, bool isDisableEditor)
+{
+  if (isSetAddressBar)
+    m_addressBar.set_text(path);
+
+  if (!title.empty())
+    set_title(title + " - " + appName_);
+  else
+    set_title(appName_);
+
+  if (isDisableEditor && isEditorEnabled())
+    disableEdit();
+
+  // Do not insert history back/forward calls into the history (again)
+  if (!isHistoryRequest && !path.empty())
+  {
+    if (history_.empty())
+    {
+      history_.push_back(path);
+      currentHistoryIndex_ = history_.size() - 1;
+    }
+    else if (history_.back().compare(path) != 0)
+    {
+      history_.push_back(path);
+      currentHistoryIndex_ = history_.size() - 1;
+    }
+  }
+  // Enable back/forward buttons when possible
+  m_backButton.set_sensitive(currentHistoryIndex_ > 0);
+  m_menu.setBackMenuSensitive(currentHistoryIndex_ > 0);
+  m_forwardButton.set_sensitive(currentHistoryIndex_ < history_.size() - 1);
+  m_menu.setForwardMenuSensitive(currentHistoryIndex_ < history_.size() - 1);
+}
+
+/**
+ * \brief Called after file is written to disk.
+ */
+void MainWindow::postWrite(const std::string& path, const std::string& title, bool isSetAddressAndTitle)
+{
+  if (isSetAddressAndTitle)
+  {
+    m_addressBar.set_text(path);
+    set_title(title + " - " + appName_);
+  }
+}
+
+/**
+ * \brief Called when request started (from thread).
+ */
+void MainWindow::startedRequest()
+{
+  // Start spinning icon
+  m_refreshIcon.get_style_context()->add_class("spinning");
+}
+
+/**
+ * \brief Called when request is finished (from thread).
+ */
+void MainWindow::finishedRequest()
+{
+  // Stop spinning icon
+  m_refreshIcon.get_style_context()->remove_class("spinning");
+}
+
+/**
+ * \brief Refresh the current page
+ */
+void MainWindow::refreshRequest()
+{
+  // Only allow refresh if editor is disabled (doesn't make sense otherwise to refresh)
+  if (!isEditorEnabled())
+    // Reload existing file, don't need to update the address bar, don't disable the editor
+    middleware_.doRequest("", false, false, false);
+}
+
+/**
+ * \brief Show startpage
+ */
+void MainWindow::showStartpage()
+{
+  m_draw_main.showStartPage();
+}
+
+/**
+ * \brief Set plain text
+ * \param content content string
+ */
+void MainWindow::setText(const Glib::ustring& content)
+{
+  m_draw_main.setText(content);
+}
+
+/**
+ * \brief Set markdown document (cmark). cmark_node pointer will be freed automatically.
+ * \param rootNode cmark root data struct
+ */
+void MainWindow::setDocument(cmark_node* rootNode)
+{
+  m_draw_main.setDocument(rootNode);
+}
+
+/**
+ * \brief Set message with optionally additional details
+ * \param message Message string
+ * \param details Details string
+ */
+void MainWindow::setMessage(const Glib::ustring& message, const Glib::ustring& details)
+{
+  m_draw_main.setMessage(message, details);
+}
+
+/**
+ * \brief Update all status fields in status pop-over menu + status icon
+ */
+void MainWindow::updateStatusPopoverAndIcon()
+{
+  std::string networkStatus;
+  std::size_t nrOfPeers = middleware_.getIPFSNumberOfPeers();
+  // Update status icon
+  if (nrOfPeers > 0)
+  {
+    networkStatus = "Connected";
+    if (useCurrentGTKIconTheme_)
+    {
+      m_statusIcon.set_from_icon_name("network-wired-symbolic", Gtk::IconSize(Gtk::ICON_SIZE_MENU));
+    }
+    else
+    {
+      m_statusIcon.set(m_statusOnlineIcon);
+    }
+  }
+  else
+  {
+    networkStatus = "Disconnected";
+    if (useCurrentGTKIconTheme_)
+    {
+      m_statusIcon.set_from_icon_name("network-wired-disconnected-symbolic", Gtk::IconSize(Gtk::ICON_SIZE_MENU));
+    }
+    else
+    {
+      m_statusIcon.set(m_statusOfflineIcon);
+    }
+  }
+  m_connectivityStatusLabel.set_markup("<b>" + networkStatus + "</b>");
+  m_peersStatusLabel.set_text(std::to_string(nrOfPeers));
+  m_repoSizeStatusLabel.set_text(std::to_string(middleware_.getIPFSRepoSize()) + " MB");
+  m_repoPathStatusLabel.set_text(middleware_.getIPFSRepoPath());
+  m_networkIncomingStatusLabel.set_text(middleware_.getIPFSIncomingRate());
+  m_networkOutcomingStatusLabel.set_text(middleware_.getIPFSOutcomingRate());
+  m_ipfsVersionStatusLabel.set_text(middleware_.getIPFSVersion());
+}
+
+/**
+ * Load stored settings from GSettings scheme file
+ */
+void MainWindow::loadStoredSettings()
+{
+  // Set additional schema directory, when browser is not yet installed
+  if (!isInstalled())
+  {
+    // Relative to the binary path
+    std::vector<std::string> relativePath{"..", "src", "gsettings"};
+    std::string schemaDir = Glib::build_path(G_DIR_SEPARATOR_S, relativePath);
+    std::cout << "INFO: Try to find the schema file using the following directory first: " << schemaDir << std::endl;
+    Glib::setenv("GSETTINGS_SCHEMA_DIR", schemaDir);
+  }
+
+  // Load schema settings file
+  auto schemaSource = Gio::SettingsSchemaSource::get_default()->lookup("org.libreweb.browser", true);
+  if (schemaSource)
+  {
+    m_settings = Gio::Settings::create("org.libreweb.browser");
+    // Apply global settings
+    set_default_size(m_settings->get_int("width"), m_settings->get_int("height"));
+    if (m_settings->get_boolean("maximized"))
+      maximize();
+
+    fontFamily_ = m_settings->get_string("font-family");
+    currentFontSize_ = defaultFontSize_ = m_settings->get_int("font-size");
+    m_fontButton.set_font_name(fontFamily_ + " " + std::to_string(currentFontSize_));
+
+    fontSpacing_ = m_settings->get_int("spacing");
+    int margins = m_settings->get_int("margins");
+    int indent = m_settings->get_int("indent");
+    m_spacingAdjustment->set_value(fontSpacing_);
+    m_marginsAdjustment->set_value(margins);
+    m_indentAdjustment->set_value(indent);
+    m_draw_main.set_left_margin(margins);
+    m_draw_main.set_right_margin(margins);
+    m_draw_main.set_indent(indent);
+
+    iconTheme_ = m_settings->get_string("icon-theme");
+    useCurrentGTKIconTheme_ = m_settings->get_boolean("icon-gtk-theme");
+    brightnessScale_ = m_settings->get_double("brightness");
+    useDarkTheme_ = m_settings->get_boolean("dark-theme");
+  }
+  else
+  {
+    std::cerr << "ERROR: Gsettings schema file could not be found!" << std::endl;
+    // Fallback settings if schema isn't found,
+    // for adjustment controls
+    int margins = 20;
+    int indent = 0;
+    m_spacingAdjustment->set_value(0);
+    m_marginsAdjustment->set_value(margins);
+    m_indentAdjustment->set_value(indent);
+    // For drawing
+    m_draw_main.set_left_margin(margins);
+    m_draw_main.set_right_margin(margins);
+    m_draw_main.set_indent(indent);
+  }
+}
+
+/**
+ * \brief set GTK Icons
+ */
+void MainWindow::setGTKIcons()
+{
+  // Toolbox buttons
+  m_backIcon.set_from_icon_name("go-previous", Gtk::IconSize(Gtk::ICON_SIZE_MENU));
+  m_forwardIcon.set_from_icon_name("go-next", Gtk::IconSize(Gtk::ICON_SIZE_MENU));
+  m_refreshIcon.set_from_icon_name("view-refresh", Gtk::IconSize(Gtk::ICON_SIZE_MENU));
+  m_homeIcon.set_from_icon_name("go-home", Gtk::IconSize(Gtk::ICON_SIZE_MENU));
+  m_searchIcon.set_from_icon_name("edit-find-symbolic", Gtk::IconSize(Gtk::ICON_SIZE_MENU));
+  m_settingsIcon.set_from_icon_name("open-menu-symbolic", Gtk::IconSize(Gtk::ICON_SIZE_MENU));
+  // Settings pop-over buttons
+  m_zoomOutImage.set_from_icon_name("zoom-out-symbolic", Gtk::IconSize(Gtk::ICON_SIZE_MENU));
+  m_zoomInImage.set_from_icon_name("zoom-in-symbolic", Gtk::IconSize(Gtk::ICON_SIZE_MENU));
+  m_brightnessImage.set_from_icon_name("display-brightness-symbolic", Gtk::IconSize(Gtk::ICON_SIZE_MENU));
+}
+
+/**
+ * Load all icon images from theme/disk. Or reload them.
+ */
+void MainWindow::loadIcons()
+{
+  try
+  {
+    // Editor buttons
+    m_openIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("open_folder", "folders"), iconSize_, iconSize_));
+    m_saveIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("floppy_disk", "basic"), iconSize_, iconSize_));
+    m_publishIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("upload", "basic"), iconSize_, iconSize_));
+    m_cutIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("cut", "editor"), iconSize_, iconSize_));
+    m_copyIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("copy", "editor"), iconSize_, iconSize_));
+    m_pasteIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("clipboard", "editor"), iconSize_, iconSize_));
+    m_undoIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("undo", "editor"), iconSize_, iconSize_));
+    m_redoIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("redo", "editor"), iconSize_, iconSize_));
+    m_boldIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("bold", "editor"), iconSize_, iconSize_));
+    m_italicIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("italic", "editor"), iconSize_, iconSize_));
+    m_strikethroughIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("strikethrough", "editor"), iconSize_, iconSize_));
+    m_superIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("superscript", "editor"), iconSize_, iconSize_));
+    m_subIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("subscript", "editor"), iconSize_, iconSize_));
+    m_linkIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("link", "editor"), iconSize_, iconSize_));
+    m_imageIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("shapes", "editor"), iconSize_, iconSize_));
+    m_emojiIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("smile", "smiley"), iconSize_, iconSize_));
+    m_quoteIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("quote", "editor"), iconSize_, iconSize_));
+    m_codeIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("code", "editor"), iconSize_, iconSize_));
+    m_bulletListIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("bullet_list", "editor"), iconSize_, iconSize_));
+    m_numberedListIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("number_list", "editor"), iconSize_, iconSize_));
+    m_hightlightIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("highlighter", "editor"), iconSize_, iconSize_));
+
+    if (useCurrentGTKIconTheme_)
+    {
+      setGTKIcons();
+    }
+    else
+    {
+      // Toolbox buttons
+      m_backIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("right_arrow_1", "arrows"), iconSize_, iconSize_)->flip());
+      m_forwardIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("right_arrow_1", "arrows"), iconSize_, iconSize_));
+      m_refreshIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("reload_centered", "arrows"), iconSize_ * 1.13, iconSize_));
+      m_homeIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("home", "basic"), iconSize_, iconSize_));
+      m_searchIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("search", "basic"), iconSize_, iconSize_));
+      m_settingsIcon.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("menu", "basic"), iconSize_, iconSize_));
+
+      // Settings pop-over buttons
+      m_zoomOutImage.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("zoom_out", "basic"), iconSize_, iconSize_));
+      m_zoomInImage.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("zoom_in", "basic"), iconSize_, iconSize_));
+      m_brightnessImage.set(Gdk::Pixbuf::create_from_file(getIconImageFromTheme("brightness", "basic"), iconSize_, iconSize_));
+      m_statusOfflineIcon = Gdk::Pixbuf::create_from_file(getIconImageFromTheme("network_disconnected", "network"), iconSize_, iconSize_);
+      m_statusOnlineIcon = Gdk::Pixbuf::create_from_file(getIconImageFromTheme("network_connected", "network"), iconSize_, iconSize_);
+    }
+  }
+  catch (const Glib::FileError& error)
+  {
+    std::cerr << "ERROR: Icon could not be loaded, file error: " << error.what() << ".\nContinue nevertheless, with GTK icons as fallback..."
+              << std::endl;
+    setGTKIcons();
+    useCurrentGTKIconTheme_ = true;
+  }
+  catch (const Gdk::PixbufError& error)
+  {
+    std::cerr << "ERROR: Icon could not be loaded, pixbuf error: " << error.what() << ".\nContinue nevertheless, with GTK icons as fallback..."
+              << std::endl;
+    setGTKIcons();
+    useCurrentGTKIconTheme_ = true;
+  }
+}
+
+/**
+ * Init all buttons / comboboxes from the toolbars
+ */
+void MainWindow::initButtons()
+{
+  // Editor buttons
+  m_openButton.set_tooltip_text("Open document (Ctrl+O)");
+  m_openButton.add(m_openIcon);
+  m_openButton.set_relief(Gtk::RELIEF_NONE);
+  m_openButton.set_can_focus(false);
+  m_saveButton.set_tooltip_text("Save document (Ctrl+S)");
+  m_saveButton.add(m_saveIcon);
+  m_saveButton.set_relief(Gtk::RELIEF_NONE);
+  m_saveButton.set_can_focus(false);
+  m_publishButton.set_tooltip_text("Publish document... (Ctrl+P)");
+  m_publishButton.add(m_publishIcon);
+  m_publishButton.set_relief(Gtk::RELIEF_NONE);
+  m_publishButton.set_can_focus(false);
+  m_cutButton.set_tooltip_text("Cut (Ctrl+X)");
+  m_cutButton.add(m_cutIcon);
+  m_cutButton.set_relief(Gtk::RELIEF_NONE);
+  m_cutButton.set_can_focus(false);
+  m_copyButton.set_tooltip_text("Copy (Ctrl+C)");
+  m_copyButton.add(m_copyIcon);
+  m_copyButton.set_relief(Gtk::RELIEF_NONE);
+  m_copyButton.set_can_focus(false);
+  m_pasteButton.set_tooltip_text("Paste (Ctrl+V)");
+  m_pasteButton.add(m_pasteIcon);
+  m_pasteButton.set_relief(Gtk::RELIEF_NONE);
+  m_pasteButton.set_can_focus(false);
+  m_undoButton.set_tooltip_text("Undo text (Ctrl+Z)");
+  m_undoButton.add(m_undoIcon);
+  m_undoButton.set_relief(Gtk::RELIEF_NONE);
+  m_undoButton.set_can_focus(false);
+  m_redoButton.set_tooltip_text("Redo text (Ctrl+Y)");
+  m_redoButton.add(m_redoIcon);
+  m_redoButton.set_relief(Gtk::RELIEF_NONE);
+  m_redoButton.set_can_focus(false);
+  m_boldButton.set_tooltip_text("Add bold text");
+  m_boldButton.add(m_boldIcon);
+  m_boldButton.set_relief(Gtk::RELIEF_NONE);
+  m_boldButton.set_can_focus(false);
+  m_italicButton.set_tooltip_text("Add italic text");
+  m_italicButton.add(m_italicIcon);
+  m_italicButton.set_relief(Gtk::RELIEF_NONE);
+  m_italicButton.set_can_focus(false);
+  m_strikethroughButton.set_tooltip_text("Add strikethrough text");
+  m_strikethroughButton.add(m_strikethroughIcon);
+  m_strikethroughButton.set_relief(Gtk::RELIEF_NONE);
+  m_strikethroughButton.set_can_focus(false);
+  m_superButton.set_tooltip_text("Add superscript text");
+  m_superButton.add(m_superIcon);
+  m_superButton.set_relief(Gtk::RELIEF_NONE);
+  m_superButton.set_can_focus(false);
+  m_subButton.set_tooltip_text("Add subscript text");
+  m_subButton.add(m_subIcon);
+  m_subButton.set_relief(Gtk::RELIEF_NONE);
+  m_subButton.set_can_focus(false);
+  m_linkButton.set_tooltip_text("Add a link");
+  m_linkButton.add(m_linkIcon);
+  m_linkButton.set_relief(Gtk::RELIEF_NONE);
+  m_linkButton.set_can_focus(false);
+  m_imageButton.set_tooltip_text("Add an image");
+  m_imageButton.add(m_imageIcon);
+  m_imageButton.set_relief(Gtk::RELIEF_NONE);
+  m_imageButton.set_can_focus(false);
+  m_emojiButton.set_tooltip_text("Insert emoji");
+  m_emojiButton.add(m_emojiIcon);
+  m_emojiButton.set_relief(Gtk::RELIEF_NONE);
+  m_emojiButton.set_can_focus(false);
+  m_quoteButton.set_tooltip_text("Insert a quote");
+  m_quoteButton.add(m_quoteIcon);
+  m_quoteButton.set_relief(Gtk::RELIEF_NONE);
+  m_quoteButton.set_can_focus(false);
+  m_codeButton.set_tooltip_text("Insert code");
+  m_codeButton.add(m_codeIcon);
+  m_codeButton.set_relief(Gtk::RELIEF_NONE);
+  m_codeButton.set_can_focus(false);
+  m_bulletListButton.set_tooltip_text("Add a bullet list");
+  m_bulletListButton.add(m_bulletListIcon);
+  m_bulletListButton.set_relief(Gtk::RELIEF_NONE);
+  m_bulletListButton.set_can_focus(false);
+  m_numberedListButton.set_tooltip_text("Add a numbered list");
+  m_numberedListButton.add(m_numberedListIcon);
+  m_numberedListButton.set_relief(Gtk::RELIEF_NONE);
+  m_numberedListButton.set_can_focus(false);
+  m_highlightButton.set_tooltip_text("Add highlight text");
+  m_highlightButton.add(m_hightlightIcon);
+  m_highlightButton.set_relief(Gtk::RELIEF_NONE);
+  m_highlightButton.set_can_focus(false);
+
+  // Disable focus the other buttons as well
+  m_searchMatchCase.set_can_focus(false);
+  m_headingsComboBox.set_can_focus(false);
+  m_headingsComboBox.set_focus_on_click(false);
+
+  // Populate the heading comboboxtext
+  m_headingsComboBox.append("", "Select Heading");
+  m_headingsComboBox.append("1", "Heading 1");
+  m_headingsComboBox.append("2", "Heading 2");
+  m_headingsComboBox.append("3", "Heading 3");
+  m_headingsComboBox.append("4", "Heading 4");
+  m_headingsComboBox.append("5", "Heading 5");
+  m_headingsComboBox.append("6", "Heading 6");
+  m_headingsComboBox.set_active(0);
+
+  // Horizontal bar
+  auto styleBack = m_backButton.get_style_context();
+  styleBack->add_class("circular");
+  auto styleForward = m_forwardButton.get_style_context();
+  styleForward->add_class("circular");
+  auto styleRefresh = m_refreshButton.get_style_context();
+  styleRefresh->add_class("circular");
+  m_searchButton.set_popover(m_searchPopover);
+  m_statusButton.set_popover(m_statusPopover);
+  m_settingsButton.set_popover(m_settingsPopover);
+  m_backButton.set_relief(Gtk::RELIEF_NONE);
+  m_forwardButton.set_relief(Gtk::RELIEF_NONE);
+  m_refreshButton.set_relief(Gtk::RELIEF_NONE);
+  m_homeButton.set_relief(Gtk::RELIEF_NONE);
+  m_searchButton.set_relief(Gtk::RELIEF_NONE);
+  m_statusButton.set_relief(Gtk::RELIEF_NONE);
+  m_settingsButton.set_relief(Gtk::RELIEF_NONE);
+
+  // Toolbar buttons
+  m_backButton.add(m_backIcon);
+  m_forwardButton.add(m_forwardIcon);
+  m_refreshButton.add(m_refreshIcon);
+  m_homeButton.add(m_homeIcon);
+  m_searchButton.add(m_searchIcon);
+
+  m_statusButton.add(m_statusIcon);
+  m_settingsButton.add(m_settingsIcon);
+
+  // Add spinning CSS class to refresh icon
+  auto cssProvider = Gtk::CssProvider::create();
+  auto screen = Gdk::Screen::get_default();
+  std::string spinningCSS = "@keyframes spin {  to { -gtk-icon-transform: rotate(1turn); }} .spinning { animation-name: spin;  "
+                            "animation-duration: 1s;  animation-timing-function: linear;  animation-iteration-count: infinite;}";
+  if (!cssProvider->load_from_data(spinningCSS))
+  {
+    std::cerr << "ERROR: CSS data parsing went wrong." << std::endl;
+  }
+  auto refreshIconStyle = m_refreshIcon.get_style_context();
+  refreshIconStyle->add_provider_for_screen(screen, cssProvider, GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
+
+  // Add tooltips to the toolbar buttons
+  m_backButton.set_tooltip_text("Go back one page (Alt+Left arrow)");
+  m_forwardButton.set_tooltip_text("Go forward one page (Alt+Right arrow)");
+  m_refreshButton.set_tooltip_text("Reload current page (Ctrl+R)");
+  m_homeButton.set_tooltip_text("Home page (Alt+Home)");
+  m_searchButton.set_tooltip_text("Find");
+  m_statusButton.set_tooltip_text("IPFS Network Status");
+  m_settingsButton.set_tooltip_text("Settings");
+
+  // Disable back/forward buttons on start-up
+  m_backButton.set_sensitive(false);
+  m_forwardButton.set_sensitive(false);
+
+  /*
+   * Adding the buttons to the boxes
+   */
+  // Browser Toolbar
+  m_backButton.set_margin_left(6);
+  m_hboxBrowserToolbar.pack_start(m_backButton, false, false, 0);
+  m_hboxBrowserToolbar.pack_start(m_forwardButton, false, false, 0);
+  m_hboxBrowserToolbar.pack_start(m_refreshButton, false, false, 0);
+  m_hboxBrowserToolbar.pack_start(m_homeButton, false, false, 0);
+  m_hboxBrowserToolbar.pack_start(m_addressBar, true, true, 4);
+  m_hboxBrowserToolbar.pack_start(m_searchButton, false, false, 0);
+  m_hboxBrowserToolbar.pack_start(m_statusButton, false, false, 0);
+  m_hboxBrowserToolbar.pack_start(m_settingsButton, false, false, 0);
+
+  // Standard editor toolbar
+  m_headingsComboBox.set_margin_left(4);
+  m_hboxStandardEditorToolbar.pack_start(m_openButton, false, false, 2);
+  m_hboxStandardEditorToolbar.pack_start(m_saveButton, false, false, 2);
+  m_hboxStandardEditorToolbar.pack_start(m_publishButton, false, false, 2);
+  m_hboxStandardEditorToolbar.pack_start(m_separator1, false, false, 0);
+  m_hboxStandardEditorToolbar.pack_start(m_cutButton, false, false, 2);
+  m_hboxStandardEditorToolbar.pack_start(m_copyButton, false, false, 2);
+  m_hboxStandardEditorToolbar.pack_start(m_pasteButton, false, false, 2);
+  m_hboxStandardEditorToolbar.pack_start(m_separator2, false, false, 0);
+  m_hboxStandardEditorToolbar.pack_start(m_undoButton, false, false, 2);
+  m_hboxStandardEditorToolbar.pack_start(m_redoButton, false, false, 2);
+
+  // Formatting toolbar
+  m_headingsComboBox.set_margin_left(4);
+  m_hboxFormattingEditorToolbar.pack_start(m_headingsComboBox, false, false, 2);
+  m_hboxFormattingEditorToolbar.pack_start(m_boldButton, false, false, 2);
+  m_hboxFormattingEditorToolbar.pack_start(m_italicButton, false, false, 2);
+  m_hboxFormattingEditorToolbar.pack_start(m_strikethroughButton, false, false, 2);
+  m_hboxFormattingEditorToolbar.pack_start(m_superButton, false, false, 2);
+  m_hboxFormattingEditorToolbar.pack_start(m_subButton, false, false, 2);
+  m_hboxFormattingEditorToolbar.pack_start(m_separator3, false, false, 0);
+  m_hboxFormattingEditorToolbar.pack_start(m_linkButton, false, false, 2);
+  m_hboxFormattingEditorToolbar.pack_start(m_imageButton, false, false, 2);
+  m_hboxFormattingEditorToolbar.pack_start(m_emojiButton, false, false, 2);
+  m_hboxFormattingEditorToolbar.pack_start(m_separator4, false, false, 0);
+  m_hboxFormattingEditorToolbar.pack_start(m_quoteButton, false, false, 2);
+  m_hboxFormattingEditorToolbar.pack_start(m_codeButton, false, false, 2);
+  m_hboxFormattingEditorToolbar.pack_start(m_bulletListButton, false, false, 2);
+  m_hboxFormattingEditorToolbar.pack_start(m_numberedListButton, false, false, 2);
+  m_hboxFormattingEditorToolbar.pack_start(m_highlightButton, false, false, 2);
+}
+
+/**
+ * \brief Prefer dark or light theme
+ */
+void MainWindow::setTheme()
+{
+  auto settings = Gtk::Settings::get_default();
+  settings->property_gtk_application_prefer_dark_theme().set_value(useDarkTheme_);
+}
+
+/**
+ * \brief Popover search bar
+ */
+void MainWindow::initSearchPopover()
+{
+  m_searchEntry.set_placeholder_text("Find");
+  m_searchReplaceEntry.set_placeholder_text("Replace");
+  m_search.connect_entry(m_searchEntry);
+  m_searchReplace.connect_entry(m_searchReplaceEntry);
+  m_searchEntry.set_size_request(250, -1);
+  m_searchReplaceEntry.set_size_request(250, -1);
+  m_vboxSearch.set_margin_left(8);
+  m_vboxSearch.set_margin_right(8);
+  m_vboxSearch.set_spacing(8);
+  m_hboxSearch.set_spacing(8);
+
+  m_hboxSearch.pack_start(m_searchEntry, false, false);
+  m_hboxSearch.pack_start(m_searchMatchCase, false, false);
+  m_vboxSearch.pack_start(m_hboxSearch, false, false, 4);
+  m_vboxSearch.pack_end(m_searchReplaceEntry, false, false, 4);
+  m_searchPopover.set_position(Gtk::POS_BOTTOM);
+  m_searchPopover.set_size_request(300, 50);
+  m_searchPopover.add(m_vboxSearch);
+  m_searchPopover.show_all_children();
+}
+
+/**
+ * Init the IPFS status pop-over
+ */
+void MainWindow::initStatusPopover()
+{
+  m_connectivityLabel.set_xalign(0.0);
+  m_peersLabel.set_xalign(0.0);
+  m_repoSizeLabel.set_xalign(0.0);
+  m_repoPathLabel.set_xalign(0.0);
+  m_ipfsVersionLabel.set_xalign(0.0);
+  m_connectivityStatusLabel.set_xalign(1.0);
+  m_peersStatusLabel.set_xalign(1.0);
+  m_repoSizeStatusLabel.set_xalign(1.0);
+  m_repoPathStatusLabel.set_xalign(1.0);
+  m_ipfsVersionStatusLabel.set_xalign(1.0);
+  m_connectivityLabel.get_style_context()->add_class("dim-label");
+  m_peersLabel.get_style_context()->add_class("dim-label");
+  m_repoSizeLabel.get_style_context()->add_class("dim-label");
+  m_repoPathLabel.get_style_context()->add_class("dim-label");
+  m_ipfsVersionLabel.get_style_context()->add_class("dim-label");
+
+  m_statusGrid.set_column_homogeneous(true);
+  m_statusGrid.set_margin_start(6);
+  m_statusGrid.set_margin_top(6);
+  m_statusGrid.set_margin_bottom(6);
+  m_statusGrid.set_margin_end(12);
+  m_statusGrid.set_row_spacing(10);
+  m_statusGrid.set_column_spacing(6);
+  m_statusGrid.attach(m_connectivityLabel, 0, 0);
+  m_statusGrid.attach(m_connectivityStatusLabel, 1, 0);
+  m_statusGrid.attach(m_peersLabel, 0, 1);
+  m_statusGrid.attach(m_peersStatusLabel, 1, 1);
+  m_statusGrid.attach(m_repoSizeLabel, 0, 2);
+  m_statusGrid.attach(m_repoSizeStatusLabel, 1, 2);
+  m_statusGrid.attach(m_repoPathLabel, 0, 3);
+  m_statusGrid.attach(m_repoPathStatusLabel, 1, 3);
+  m_statusGrid.attach(m_ipfsVersionLabel, 0, 4);
+  m_statusGrid.attach(m_ipfsVersionStatusLabel, 1, 4);
+
+  m_networkKiloBytesLabel.get_style_context()->add_class("dim-label");
+  m_activityStatusGrid.set_column_homogeneous(true);
+  m_activityStatusGrid.set_margin_start(6);
+  m_activityStatusGrid.set_margin_top(6);
+  m_activityStatusGrid.set_margin_bottom(6);
+  m_activityStatusGrid.set_margin_end(6);
+  m_activityStatusGrid.set_row_spacing(10);
+  m_activityStatusGrid.set_column_spacing(6);
+  m_activityStatusGrid.attach(m_networkIncomingLabel, 1, 0);
+  m_activityStatusGrid.attach(m_networkOutcomingLabel, 2, 0);
+  m_activityStatusGrid.attach(m_networkKiloBytesLabel, 0, 1);
+  m_activityStatusGrid.attach(m_networkIncomingStatusLabel, 1, 1);
+  m_activityStatusGrid.attach(m_networkOutcomingStatusLabel, 2, 1);
+
+  m_networkHeadingLabel.get_style_context()->add_class("dim-label");
+  m_networkRateHeadingLabel.get_style_context()->add_class("dim-label");
+
+  m_copyIDButton.set_label("Copy your ID");
+  m_copyPublicKeyButton.set_label("Copy Public Key");
+  m_copyIDButton.set_margin_start(6);
+  m_copyIDButton.set_margin_end(6);
+  m_copyPublicKeyButton.set_margin_start(6);
+  m_copyPublicKeyButton.set_margin_end(6);
+
+  m_vboxStatus.set_margin_start(10);
+  m_vboxStatus.set_margin_end(10);
+  m_vboxStatus.set_margin_top(10);
+  m_vboxStatus.set_margin_bottom(10);
+  m_vboxStatus.set_spacing(6);
+  m_vboxStatus.add(m_networkHeadingLabel);
+  m_vboxStatus.add(m_statusGrid);
+  m_vboxStatus.add(m_separator9);
+  m_vboxStatus.add(m_networkRateHeadingLabel);
+  m_vboxStatus.add(m_activityStatusGrid);
+  m_vboxStatus.add(m_separator10);
+  m_vboxStatus.add(m_copyPublicKeyButton);
+  m_vboxStatus.add(m_copyIDButton);
+  m_statusPopover.set_position(Gtk::POS_BOTTOM);
+  m_statusPopover.set_size_request(100, 250);
+  m_statusPopover.set_margin_end(2);
+  m_statusPopover.add(m_vboxStatus);
+  m_statusPopover.show_all_children();
+
+  // Set fallback values for all status fields + status icon
+  updateStatusPopoverAndIcon();
+}
+
+/**
+ * Init the settings pop-over
+ */
+void MainWindow::initSettingsPopover()
+{
+  // Toolbar buttons / images
+  m_zoomOutButton.add(m_zoomOutImage);
+  m_zoomInButton.add(m_zoomInImage);
+  m_brightnessImage.set_tooltip_text("Brightness");
+  m_brightnessImage.set_margin_start(2);
+  m_brightnessImage.set_margin_end(2);
+  m_brightnessImage.set_margin_top(1);
+  m_brightnessImage.set_margin_bottom(1);
+
+  // Zoom buttons
+  auto hboxZoomStyleContext = m_hboxSetingsZoom.get_style_context();
+  hboxZoomStyleContext->add_class("linked");
+  m_zoomRestoreButton.set_sensitive(false); // By default restore button disabled
+  m_zoomRestoreButton.set_label("100%");
+  m_zoomOutButton.set_tooltip_text("Zoom out");
+  m_zoomRestoreButton.set_tooltip_text("Restore zoom");
+  m_zoomInButton.set_tooltip_text("Zoom in");
+  m_hboxSetingsZoom.set_size_request(-1, 40);
+  m_hboxSetingsZoom.set_margin_bottom(6);
+  m_hboxSetingsZoom.pack_start(m_zoomOutButton);
+  m_hboxSetingsZoom.pack_start(m_zoomRestoreButton);
+  m_hboxSetingsZoom.pack_end(m_zoomInButton);
+
+  // Brightness slider
+  m_brightnessAdjustment->set_value(brightnessScale_); // Override with current loaded brightness setting
+  m_scaleSettingsBrightness.set_adjustment(m_brightnessAdjustment);
+  m_scaleSettingsBrightness.add_mark(0.5, Gtk::PositionType::POS_BOTTOM, "");
+  m_scaleSettingsBrightness.set_draw_value(false);
+  m_scaleSettingsBrightness.signal_value_changed().connect(sigc::mem_fun(this, &MainWindow::on_brightness_changed));
+  m_hboxSetingsBrightness.pack_start(m_brightnessImage, false, false);
+  m_hboxSetingsBrightness.pack_end(m_scaleSettingsBrightness);
+
+  // Dark theme switch
+  m_themeSwitch.set_active(useDarkTheme_); // Override with current dark theme preference
+
+  // Spin buttons
+  m_spacingSpinButton.set_adjustment(m_spacingAdjustment);
+  m_marginsSpinButton.set_adjustment(m_marginsAdjustment);
+  m_indentSpinButton.set_adjustment(m_indentAdjustment);
+  m_fontLabel.set_xalign(1);
+  m_spacingLabel.set_xalign(1);
+  m_marginsLabel.set_xalign(1);
+  m_indentLabel.set_xalign(1);
+  m_themeLabel.set_xalign(1);
+  m_fontLabel.get_style_context()->add_class("dim-label");
+  m_spacingLabel.get_style_context()->add_class("dim-label");
+  m_marginsLabel.get_style_context()->add_class("dim-label");
+  m_indentLabel.get_style_context()->add_class("dim-label");
+  m_themeLabel.get_style_context()->add_class("dim-label");
+  m_settingsGrid.set_margin_start(6);
+  m_settingsGrid.set_margin_top(6);
+  m_settingsGrid.set_margin_bottom(6);
+  m_settingsGrid.set_row_spacing(10);
+  m_settingsGrid.set_column_spacing(10);
+  m_settingsGrid.attach(m_fontLabel, 0, 0);
+  m_settingsGrid.attach(m_fontButton, 1, 0);
+  m_settingsGrid.attach(m_spacingLabel, 0, 1);
+  m_settingsGrid.attach(m_spacingSpinButton, 1, 1);
+  m_settingsGrid.attach(m_marginsLabel, 0, 2);
+  m_settingsGrid.attach(m_marginsSpinButton, 1, 2);
+  m_settingsGrid.attach(m_indentLabel, 0, 3);
+  m_settingsGrid.attach(m_indentSpinButton, 1, 3);
+  m_settingsGrid.attach(m_themeLabel, 0, 4);
+  m_settingsGrid.attach(m_themeSwitch, 1, 4);
+
+  // Icon theme (+ submenu)
+  m_iconThemeButton.set_label("Icon Theme");
+  m_iconThemeButton.property_menu_name() = "icon-theme";
+  m_aboutButton.set_label("About LibreWeb");
+  Gtk::Label* iconThemeButtonlabel = dynamic_cast<Gtk::Label*>(m_iconThemeButton.get_child());
+  iconThemeButtonlabel->set_xalign(0.0);
+  Gtk::Label* aboutButtonLabel = dynamic_cast<Gtk::Label*>(m_aboutButton.get_child());
+  iconThemeButtonlabel->set_xalign(0.0);
+  aboutButtonLabel->set_xalign(0.0);
+
+  // Add Settings vbox to popover menu
+  m_vboxSettings.set_margin_start(10);
+  m_vboxSettings.set_margin_end(10);
+  m_vboxSettings.set_margin_top(10);
+  m_vboxSettings.set_margin_bottom(10);
+  m_vboxSettings.set_spacing(8);
+  m_vboxSettings.add(m_hboxSetingsZoom);
+  m_vboxSettings.add(m_hboxSetingsBrightness);
+  m_vboxSettings.add(m_separator5);
+  m_vboxSettings.add(m_settingsGrid);
+  m_vboxSettings.add(m_separator6);
+  m_vboxSettings.add(m_iconThemeButton);
+  m_vboxSettings.add(m_separator7);
+  m_vboxSettings.pack_end(m_aboutButton, false, false);
+  m_settingsPopover.set_position(Gtk::POS_BOTTOM);
+  m_settingsPopover.set_size_request(200, 300);
+  m_settingsPopover.set_margin_end(2);
+  m_settingsPopover.add(m_vboxSettings);
+
+  // Add Theme vbox to popover menu
+  m_iconThemeBackButton.set_label("Icon Theme");
+  m_iconThemeBackButton.property_menu_name() = "main";
+  m_iconThemeBackButton.property_inverted() = true;
+  // List of themes in list box
+  Gtk::Label* iconTheme1 = Gtk::manage(new Gtk::Label("Flat theme"));
+  Gtk::ListBoxRow* row1 = Gtk::manage(new Gtk::ListBoxRow());
+  row1->add(*iconTheme1);
+  row1->set_data("value", (void*)"flat");
+  Gtk::Label* iconTheme2 = Gtk::manage(new Gtk::Label("Filled theme"));
+  Gtk::ListBoxRow* row2 = Gtk::manage(new Gtk::ListBoxRow());
+  row2->add(*iconTheme2);
+  row2->set_data("value", (void*)"filled");
+  Gtk::Label* iconTheme3 = Gtk::manage(new Gtk::Label("Gtk default theme"));
+  Gtk::ListBoxRow* row3 = Gtk::manage(new Gtk::ListBoxRow());
+  row3->add(*iconTheme3);
+  row3->set_data("value", (void*)"none");
+  m_iconThemeListBox.add(*row1);
+  m_iconThemeListBox.add(*row2);
+  m_iconThemeListBox.add(*row3);
+  m_iconThemeListBox.select_row(*row1); // TODO: Select the correct theme on loading
+  m_iconThemeListScrolledWindow.property_height_request() = 200;
+  m_iconThemeListScrolledWindow.add(m_iconThemeListBox);
+  m_iconThemeLabel.get_style_context()->add_class("dim-label");
+  m_vboxIconTheme.add(m_iconThemeBackButton);
+  m_vboxIconTheme.add(m_separator8);
+  m_vboxIconTheme.add(m_iconThemeLabel);
+  m_vboxIconTheme.add(m_iconThemeListScrolledWindow);
+  m_settingsPopover.add(m_vboxIconTheme);
+  m_settingsPopover.child_property_submenu(m_vboxIconTheme) = "icon-theme";
+  m_settingsPopover.show_all_children();
+}
+
+/**
+ * \brief Init all signals and connect them to functions
+ */
+void MainWindow::initSignals()
+{
+  // Window signals
+  signal_delete_event().connect(sigc::mem_fun(this, &MainWindow::delete_window));
+
+  // Menu & toolbar signals
+  m_menu.new_doc.connect(sigc::mem_fun(this, &MainWindow::new_doc));                       /*!< Menu item for new document */
+  m_menu.open.connect(sigc::mem_fun(this, &MainWindow::open));                             /*!< Menu item for opening existing document */
+  m_menu.open_edit.connect(sigc::mem_fun(this, &MainWindow::open_and_edit));               /*!< Menu item for opening & editing existing document */
+  m_menu.edit.connect(sigc::mem_fun(this, &MainWindow::edit));                             /*!< Menu item for editing current open document */
+  m_menu.save.connect(sigc::mem_fun(this, &MainWindow::save));                             /*!< Menu item for save document */
+  m_menu.save_as.connect(sigc::mem_fun(this, &MainWindow::save_as));                       /*!< Menu item for save document as */
+  m_menu.publish.connect(sigc::mem_fun(this, &MainWindow::publish));                       /*!< Menu item for publishing */
+  m_menu.quit.connect(sigc::mem_fun(this, &MainWindow::close));                            /*!< close main window and therefor closes the app */
+  m_menu.undo.connect(sigc::mem_fun(m_draw_main, &Draw::undo));                            /*!< Menu item for undo text */
+  m_menu.redo.connect(sigc::mem_fun(m_draw_main, &Draw::redo));                            /*!< Menu item for redo text */
+  m_menu.cut.connect(sigc::mem_fun(this, &MainWindow::cut));                               /*!< Menu item for cut text */
+  m_menu.copy.connect(sigc::mem_fun(this, &MainWindow::copy));                             /*!< Menu item for copy text */
+  m_menu.paste.connect(sigc::mem_fun(this, &MainWindow::paste));                           /*!< Menu item for paste text */
+  m_menu.del.connect(sigc::mem_fun(this, &MainWindow::del));                               /*!< Menu item for deleting selected text */
+  m_menu.select_all.connect(sigc::mem_fun(this, &MainWindow::selectAll));                  /*!< Menu item for selecting all text */
+  m_menu.find.connect(sigc::bind(sigc::mem_fun(this, &MainWindow::show_search), false));   /*!< Menu item for finding text */
+  m_menu.replace.connect(sigc::bind(sigc::mem_fun(this, &MainWindow::show_search), true)); /*!< Menu item for replacing text */
+  m_menu.back.connect(sigc::mem_fun(this, &MainWindow::back));                             /*!< Menu item for previous page */
+  m_menu.forward.connect(sigc::mem_fun(this, &MainWindow::forward));                       /*!< Menu item for next page */
+  m_menu.reload.connect(sigc::mem_fun(this, &MainWindow::refreshRequest));                 /*!< Menu item for reloading the page */
+  m_menu.home.connect(sigc::mem_fun(this, &MainWindow::go_home));                          /*!< Menu item for home page */
+  m_menu.source_code.connect(sigc::mem_fun(this, &MainWindow::show_source_code_dialog));   /*!< Source code dialog */
+  m_sourceCodeDialog.signal_response().connect(sigc::mem_fun(m_sourceCodeDialog, &SourceCodeDialog::hide_dialog)); /*!< Close source code dialog */
+  m_menu.about.connect(sigc::mem_fun(m_about, &About::show_about));                                                /*!< Display about dialog */
+  m_draw_main.source_code.connect(sigc::mem_fun(this, &MainWindow::show_source_code_dialog));                      /*!< Open source code dialog */
+  m_about.signal_response().connect(sigc::mem_fun(m_about, &About::hide_about));                                   /*!< Close about dialog */
+  m_addressBar.signal_activate().connect(sigc::mem_fun(this, &MainWindow::address_bar_activate)); /*!< User pressed enter the address bar */
+  m_backButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::back));                  /*!< Button for previous page */
+  m_forwardButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::forward));            /*!< Button for next page */
+  m_refreshButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::refreshRequest));     /*!< Button for reloading the page */
+  m_homeButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::go_home));               /*!< Button for home page */
+  m_searchEntry.signal_activate().connect(sigc::mem_fun(this, &MainWindow::on_search));           /*!< Execute the text search */
+  m_searchReplaceEntry.signal_activate().connect(sigc::mem_fun(this, &MainWindow::on_replace));   /*!< Execute the text replace */
+
+  // Editor buttons
+  m_openButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::open_and_edit));
+  m_saveButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::save));
+  m_publishButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::publish));
+  m_cutButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::cut));
+  m_copyButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::copy));
+  m_pasteButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::paste));
+  m_undoButton.signal_clicked().connect(sigc::mem_fun(m_draw_main, &Draw::undo));
+  m_redoButton.signal_clicked().connect(sigc::mem_fun(m_draw_main, &Draw::redo));
+  m_headingsComboBox.signal_changed().connect(sigc::mem_fun(this, &MainWindow::get_heading));
+  m_boldButton.signal_clicked().connect(sigc::mem_fun(m_draw_main, &Draw::make_bold));
+  m_italicButton.signal_clicked().connect(sigc::mem_fun(m_draw_main, &Draw::make_italic));
+  m_strikethroughButton.signal_clicked().connect(sigc::mem_fun(m_draw_main, &Draw::make_strikethrough));
+  m_superButton.signal_clicked().connect(sigc::mem_fun(m_draw_main, &Draw::make_super));
+  m_subButton.signal_clicked().connect(sigc::mem_fun(m_draw_main, &Draw::make_sub));
+  m_linkButton.signal_clicked().connect(sigc::mem_fun(m_draw_main, &Draw::insert_link));
+  m_imageButton.signal_clicked().connect(sigc::mem_fun(m_draw_main, &Draw::insert_image));
+  m_emojiButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::insert_emoji));
+  m_quoteButton.signal_clicked().connect(sigc::mem_fun(m_draw_main, &Draw::make_quote));
+  m_codeButton.signal_clicked().connect(sigc::mem_fun(m_draw_main, &Draw::make_code));
+  m_bulletListButton.signal_clicked().connect(sigc::mem_fun(m_draw_main, &Draw::insert_bullet_list));
+  m_numberedListButton.signal_clicked().connect(sigc::mem_fun(m_draw_main, &Draw::insert_numbered_list));
+  m_highlightButton.signal_clicked().connect(sigc::mem_fun(m_draw_main, &Draw::make_highlight));
+
+  // Status pop-over buttons
+  m_copyIDButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::copy_client_id));
+  m_copyPublicKeyButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::copy_client_public_key));
+
+  // Settings pop-over buttons
+  m_zoomOutButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::on_zoom_out));
+  m_zoomRestoreButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::on_zoom_restore));
+  m_zoomInButton.signal_clicked().connect(sigc::mem_fun(this, &MainWindow::on_zoom_in));
+  m_fontButton.signal_font_set().connect(sigc::mem_fun(this, &MainWindow::on_font_set));
+  m_spacingSpinButton.signal_value_changed().connect(sigc::mem_fun(this, &MainWindow::on_spacing_changed));
+  m_marginsSpinButton.signal_value_changed().connect(sigc::mem_fun(this, &MainWindow::on_margins_changed));
+  m_indentSpinButton.signal_value_changed().connect(sigc::mem_fun(this, &MainWindow::on_indent_changed));
+  m_themeSwitch.property_active().signal_changed().connect(sigc::mem_fun(this, &MainWindow::on_theme_changed));
+  m_iconThemeListBox.signal_row_activated().connect(sigc::mem_fun(this, &MainWindow::on_icon_theme_activated));
+  m_aboutButton.signal_clicked().connect(sigc::mem_fun(m_about, &About::show_about));
+}
+
+/**
+ * \brief Called when Window is closed/exited
+ */
+bool MainWindow::delete_window(GdkEventAny* any_event __attribute__((unused)))
+{
+  if (m_settings)
+  {
+    // Save the schema settings
+    m_settings->set_int("width", get_width());
+    m_settings->set_int("height", get_height());
+    m_settings->set_boolean("maximized", is_maximized());
+    // Only store a divider value bigger than zero,
+    // because the secondary draw window is hidden by default, resulting into a zero value.
+    if (m_paned.get_position() > 0)
+      m_settings->set_int("position-divider", m_paned.get_position());
+
+    // Fullscreen will be availible with gtkmm-4.0
+    // m_settings->set_boolean("fullscreen", is_fullscreen());
+
+    m_settings->set_string("font-family", fontFamily_);
+    m_settings->set_int("font-size", currentFontSize_);
+    m_settings->set_int("spacing", m_spacingSpinButton.get_value_as_int());
+    m_settings->set_int("margins", m_marginsSpinButton.get_value_as_int());
+    m_settings->set_int("indent", m_indentSpinButton.get_value_as_int());
+    m_settings->set_string("icon-theme", iconTheme_);
+    m_settings->set_boolean("icon-gtk-theme", useCurrentGTKIconTheme_);
+    m_settings->set_double("brightness", brightnessScale_);
+    m_settings->set_boolean("dark-theme", useDarkTheme_);
+  }
+  return false;
+}
+
+/**
+ * \brief Cut/copy/paste/delete/select all keybindings
+ */
+void MainWindow::cut()
+{
+  if (m_draw_main.has_focus())
+  {
+    m_draw_main.cut();
+  }
+  else if (m_draw_secondary.has_focus())
+  {
+    m_draw_secondary.cut();
+  }
+  else if (m_addressBar.has_focus())
+  {
+    m_addressBar.cut_clipboard();
+  }
+  else if (m_searchEntry.has_focus())
+  {
+    m_searchEntry.cut_clipboard();
+  }
+  else if (m_searchReplaceEntry.has_focus())
+  {
+    m_searchReplaceEntry.cut_clipboard();
+  }
+}
+
+void MainWindow::copy()
+{
+  if (m_draw_main.has_focus())
+  {
+    m_draw_main.copy();
+  }
+  else if (m_draw_secondary.has_focus())
+  {
+    m_draw_secondary.copy();
+  }
+  else if (m_addressBar.has_focus())
+  {
+    m_addressBar.copy_clipboard();
+  }
+  else if (m_searchEntry.has_focus())
+  {
+    m_searchEntry.copy_clipboard();
+  }
+  else if (m_searchReplaceEntry.has_focus())
+  {
+    m_searchReplaceEntry.copy_clipboard();
+  }
+}
+
+void MainWindow::paste()
+{
+  if (m_draw_main.has_focus())
+  {
+    m_draw_main.paste();
+  }
+  else if (m_draw_secondary.has_focus())
+  {
+    m_draw_secondary.paste();
+  }
+  else if (m_addressBar.has_focus())
+  {
+    m_addressBar.paste_clipboard();
+  }
+  else if (m_searchEntry.has_focus())
+  {
+    m_searchEntry.paste_clipboard();
+  }
+  else if (m_searchReplaceEntry.has_focus())
+  {
+    m_searchReplaceEntry.paste_clipboard();
+  }
+}
+
+void MainWindow::del()
+{
+  if (m_draw_main.has_focus())
+  {
+    m_draw_main.del();
+  }
+  else if (m_draw_secondary.has_focus())
+  {
+    m_draw_secondary.del();
+  }
+  else if (m_addressBar.has_focus())
+  {
+    int start, end;
+    if (m_addressBar.get_selection_bounds(start, end))
+    {
+      m_addressBar.delete_text(start, end);
+    }
+    else
+    {
+      ++end;
+      m_addressBar.delete_text(start, end);
+    }
+  }
+  else if (m_searchEntry.has_focus())
+  {
+    int start, end;
+    if (m_searchEntry.get_selection_bounds(start, end))
+    {
+      m_searchEntry.delete_text(start, end);
+    }
+    else
+    {
+      ++end;
+      m_searchEntry.delete_text(start, end);
+    }
+  }
+  else if (m_searchReplaceEntry.has_focus())
+  {
+    int start, end;
+    if (m_searchReplaceEntry.get_selection_bounds(start, end))
+    {
+      m_searchReplaceEntry.delete_text(start, end);
+    }
+    else
+    {
+      ++end;
+      m_searchReplaceEntry.delete_text(start, end);
+    }
+  }
+}
+
+void MainWindow::selectAll()
+{
+  if (m_draw_main.has_focus())
+  {
+    m_draw_main.selectAll();
+  }
+  else if (m_draw_secondary.has_focus())
+  {
+    m_draw_secondary.selectAll();
+  }
+  else if (m_addressBar.has_focus())
+  {
+    m_addressBar.select_region(0, -1);
+  }
+  else if (m_searchEntry.has_focus())
+  {
+    m_searchEntry.select_region(0, -1);
+  }
+  else if (m_searchReplaceEntry.has_focus())
+  {
+    m_searchReplaceEntry.select_region(0, -1);
+  }
+}
+
+/**
+ * \brief Trigger when user selected 'new document' from menu item
+ */
+void MainWindow::new_doc()
+{
+  // Clear content & path
+  middleware_.resetContentAndPath();
+  // Enable editing mode
+  enableEdit();
+  // Change address bar
+  m_addressBar.set_text("file://unsaved");
+  // Set new title
+  set_title("Untitled * - " + appName_);
+}
+
+/**
+ * \brief Triggered when user selected 'open...' from menu item / toolbar
+ */
+void MainWindow::open()
+{
+  auto dialog = new Gtk::FileChooserDialog("Open", Gtk::FILE_CHOOSER_ACTION_OPEN);
+  dialog->set_transient_for(*this);
+  dialog->set_modal(true);
+  dialog->signal_response().connect(sigc::bind(sigc::mem_fun(*this, &MainWindow::on_open_dialog_response), dialog));
+  dialog->add_button("_Cancel", Gtk::ResponseType::RESPONSE_CANCEL);
+  dialog->add_button("_Open", Gtk::ResponseType::RESPONSE_OK);
+
+  // Add filters, so that only certain file types can be selected:
+#ifdef __linux__
+  auto filterMarkdown = Gtk::FileFilter::create();
+  filterMarkdown->set_name("All Markdown files");
+  filterMarkdown->add_mime_type("text/markdown");
+  dialog->add_filter(filterMarkdown);
+#endif
+
+  auto filterMarkdownExt = Gtk::FileFilter::create();
+  filterMarkdownExt->set_name("All Markdown files extension (*.md)");
+  filterMarkdownExt->add_pattern("*.md");
+  dialog->add_filter(filterMarkdownExt);
+
+  auto filterTextFiles = Gtk::FileFilter::create();
+  filterTextFiles->set_name("All text files");
+  filterTextFiles->add_mime_type("text/plain");
+  dialog->add_filter(filterTextFiles);
+
+  auto filterAny = Gtk::FileFilter::create();
+  filterAny->set_name("Any files");
+  filterAny->add_pattern("*");
+  dialog->add_filter(filterAny);
+
+  dialog->show();
+}
+
+/**
+ * \brief Triggered when user selected 'open & edit...' from menu item
+ */
+void MainWindow::open_and_edit()
+{
+  auto dialog = new Gtk::FileChooserDialog("Open & Edit", Gtk::FILE_CHOOSER_ACTION_OPEN);
+  dialog->set_transient_for(*this);
+  dialog->set_modal(true);
+  dialog->signal_response().connect(sigc::bind(sigc::mem_fun(*this, &MainWindow::on_open_edit_dialog_response), dialog));
+  dialog->add_button("_Cancel", Gtk::ResponseType::RESPONSE_CANCEL);
+  dialog->add_button("_Open", Gtk::ResponseType::RESPONSE_OK);
+
+  // Add filters, so that only certain file types can be selected:
+#ifdef __linux__
+  auto filterMarkdown = Gtk::FileFilter::create();
+  filterMarkdown->set_name("All Markdown files");
+  filterMarkdown->add_mime_type("text/markdown");
+  dialog->add_filter(filterMarkdown);
+#endif
+
+  auto filterMarkdownExt = Gtk::FileFilter::create();
+  filterMarkdownExt->set_name("All Markdown files extension (*.md)");
+  filterMarkdownExt->add_pattern("*.md");
+  dialog->add_filter(filterMarkdownExt);
+
+  auto filterTextFiles = Gtk::FileFilter::create();
+  filterTextFiles->set_name("All text files");
+  filterTextFiles->add_mime_type("text/plain");
+  dialog->add_filter(filterTextFiles);
+
+  auto filterAny = Gtk::FileFilter::create();
+  filterAny->set_name("Any files");
+  filterAny->add_pattern("*");
+  dialog->add_filter(filterAny);
+
+  dialog->show();
+}
+
+/**
+ * \brief Signal response when 'open' dialog is closed
+ */
+void MainWindow::on_open_dialog_response(int response_id, Gtk::FileChooserDialog* dialog)
+{
+  switch (response_id)
+  {
+  case Gtk::ResponseType::RESPONSE_OK:
+  {
+    auto filePath = dialog->get_file()->get_path();
+    // Open file, set address bar & disable editor if needed
+    middleware_.doRequest("file://" + filePath);
+    break;
+  }
+  case Gtk::ResponseType::RESPONSE_CANCEL:
+  {
+    break;
+  }
+  default:
+  {
+    std::cerr << "WARN: Unexpected button clicked." << std::endl;
+    break;
+  }
+  }
+  delete dialog;
+}
+
+/**
+ * \brief Signal response when 'open & edit' dialog is closed
+ */
+void MainWindow::on_open_edit_dialog_response(int response_id, Gtk::FileChooserDialog* dialog)
+{
+  switch (response_id)
+  {
+  case Gtk::ResponseType::RESPONSE_OK:
+  {
+    // Enable editor if needed
+    if (!isEditorEnabled())
+      enableEdit();
+
+    auto filePath = dialog->get_file()->get_path();
+    std::string path = "file://" + filePath;
+    // Open file and set address bar, but do not parse the content or the disable editor
+    middleware_.doRequest(path, true, false, false, false);
+    // Set current file path for the 'save' feature
+    currentFileSavedPath_ = filePath;
+    break;
+  }
+  case Gtk::ResponseType::RESPONSE_CANCEL:
+  {
+    break;
+  }
+  default:
+  {
+    std::cerr << "WARN: Unexpected button clicked." << std::endl;
+    break;
+  }
+  }
+  delete dialog;
+}
+
+/**
+ * \brief Triggered when user selected 'edit' from menu item
+ */
+void MainWindow::edit()
+{
+  if (!isEditorEnabled())
+    enableEdit();
+
+  m_draw_main.setText(middleware_.getContent());
+  // Set title
+  set_title("Untitled * - " + appName_);
+}
+
+/**
+ * \brief Triggered when user selected 'save' from menu item / toolbar
+ */
+void MainWindow::save()
+{
+  if (currentFileSavedPath_.empty())
+  {
+    save_as();
+  }
+  else
+  {
+    if (isEditorEnabled())
+    {
+      try
+      {
+        middleware_.doWrite(currentFileSavedPath_);
+      }
+      catch (std::ios_base::failure& error)
+      {
+        std::cerr << "ERROR: Could not write file: " << currentFileSavedPath_ << ". Message: " << error.what() << ".\nError code: " << error.code()
+                  << std::endl;
+      }
+    }
+    else
+    {
+      std::cerr << "ERROR: Saving while \"file saved path\" is filled and editor is disabled should not happen!?" << std::endl;
+    }
+  }
+}
+
+/**
+ * \brief Triggered when 'save as..' menu item is selected or the user saves the file for the first time via 'save'
+ */
+void MainWindow::save_as()
+{
+  auto dialog = new Gtk::FileChooserDialog("Save", Gtk::FILE_CHOOSER_ACTION_SAVE);
+  dialog->set_transient_for(*this);
+
+  dialog->set_modal(true);
+  dialog->set_do_overwrite_confirmation(true);
+  dialog->signal_response().connect(sigc::bind(sigc::mem_fun(*this, &MainWindow::on_save_as_dialog_response), dialog));
+  dialog->add_button("_Cancel", Gtk::ResponseType::RESPONSE_CANCEL);
+  dialog->add_button("_Save", Gtk::ResponseType::RESPONSE_OK);
+
+  // Add filters, so that only certain file types can be selected:
+  auto filterMarkdownExt = Gtk::FileFilter::create();
+  filterMarkdownExt->set_name("All Markdown files");
+  filterMarkdownExt->add_pattern("*.md");
+  dialog->add_filter(filterMarkdownExt);
+
+  auto filterTextFiles = Gtk::FileFilter::create();
+  filterTextFiles->set_name("All text files");
+  filterTextFiles->add_mime_type("text/plain");
+  dialog->add_filter(filterTextFiles);
+
+  auto filterAny = Gtk::FileFilter::create();
+  filterAny->set_name("Any files");
+  filterAny->add_pattern("*");
+  dialog->add_filter(filterAny);
+
+  // If user is saving as an existing file, set the current uri path
+  if (!currentFileSavedPath_.empty())
+  {
+    try
+    {
+      dialog->set_uri(Glib::filename_to_uri(currentFileSavedPath_));
+    }
+    catch (Glib::Error& error)
+    {
+      std::cerr << "ERROR: Incorrect filename most likely. Message: " << error.what() << ". Error Code: " << error.code() << std::endl;
+    }
+  }
+  dialog->show();
+}
+
+/**
+ * \brief Signal response when 'save as' dialog is closed
+ */
+void MainWindow::on_save_as_dialog_response(int response_id, Gtk::FileChooserDialog* dialog)
+{
+  switch (response_id)
+  {
+  case Gtk::ResponseType::RESPONSE_OK:
+  {
+    auto filePath = dialog->get_file()->get_path();
+    if (!filePath.ends_with(".md"))
+      filePath.append(".md");
+
+    // Save current content to file path
+    try
+    {
+      middleware_.doWrite(filePath, isEditorEnabled()); // Only update address & title, when editor mode is enabled
+      // Only if editor mode is enabled
+      if (isEditorEnabled())
+      {
+        // Set/update the current file saved path variable (used for the 'save' feature)
+        currentFileSavedPath_ = filePath;
+      }
+    }
+    catch (std::ios_base::failure& error)
+    {
+      std::cerr << "ERROR: Could not write file: " << filePath << ". Message: " << error.what() << ".\nError code: " << error.code() << std::endl;
+    }
+    break;
+  }
+  case Gtk::ResponseType::RESPONSE_CANCEL:
+  {
+    break;
+  }
+  default:
+  {
+    std::cerr << "ERROR: Unexpected button clicked." << std::endl;
+    break;
+  }
+  }
+  delete dialog;
+}
+
+/**
+ * \brief Triggered when user selected the 'Publish...' menu item or publish button in the toolbar
+ */
+void MainWindow::publish()
+{
+  int result = Gtk::RESPONSE_YES; // By default continue
+  if (middleware_.getContent().empty())
+  {
+    Gtk::MessageDialog dialog(*this, "Are you sure you want to publish <b>empty</b> content?", true, Gtk::MESSAGE_QUESTION, Gtk::BUTTONS_YES_NO);
+    dialog.set_title("Are you sure?");
+    dialog.set_default_response(Gtk::RESPONSE_NO);
+    result = dialog.run();
+  }
+
+  // Continue ...
+  if (result == Gtk::RESPONSE_YES)
+  {
+    std::string path = "new_file.md";
+    // Retrieve filename from saved file (if present)
+    if (!currentFileSavedPath_.empty())
+    {
+      path = currentFileSavedPath_;
+    }
+    else
+    {
+      // TODO: path is not defined yet. however, this may change anyway once we try to build more complex
+      // websites, needing to use directory structures.
+    }
+
+    try
+    {
+      // Add content to IPFS
+      std::string cid = middleware_.doAdd(path);
+      if (cid.empty())
+      {
+        throw std::runtime_error("CID hash is empty.");
+      }
+      // Show dialog
+      m_contentPublishedDialog.reset(new Gtk::MessageDialog(*this, "File is successfully added to IPFS!"));
+      m_contentPublishedDialog->set_secondary_text("The content is now available on the decentralized web, via:");
+      // Add custom label
+      Gtk::Label* label = Gtk::manage(new Gtk::Label("ipfs://" + cid));
+      label->set_selectable(true);
+      Gtk::Box* box = m_contentPublishedDialog->get_content_area();
+      box->pack_end(*label);
+
+      m_contentPublishedDialog->set_modal(true);
+      // m_contentPublishedDialog->set_hide_on_close(true); available in gtk-4.0
+      m_contentPublishedDialog->signal_response().connect(sigc::hide(sigc::mem_fun(*m_contentPublishedDialog, &Gtk::Widget::hide)));
+      m_contentPublishedDialog->show_all();
+    }
+    catch (const std::runtime_error& error)
+    {
+      m_contentPublishedDialog.reset(new Gtk::MessageDialog(*this, "File could not be added to IPFS", false, Gtk::MESSAGE_ERROR));
+      m_contentPublishedDialog->set_secondary_text("Error message: " + std::string(error.what()));
+      m_contentPublishedDialog->set_modal(true);
+      // m_contentPublishedDialog->set_hide_on_close(true); available in gtk-4.0
+      m_contentPublishedDialog->signal_response().connect(sigc::hide(sigc::mem_fun(*m_contentPublishedDialog, &Gtk::Widget::hide)));
+      m_contentPublishedDialog->show();
+    }
+  }
+}
+
+/**
+ * \brief Show homepage
+ */
+void MainWindow::go_home()
+{
+  middleware_.doRequest("about:home", true, false, true);
+}
+
+/**
+ * \brief Copy the IPFS Client ID to clipboard
+ */
+void MainWindow::copy_client_id()
+{
+  if (!middleware_.getIPFSClientId().empty())
+  {
+    get_clipboard("CLIPBOARD")->set_text(middleware_.getIPFSClientId());
+    showNotification("Copied to clipboard", "Your client ID is now copied to your clipboard.");
+  }
+  else
+  {
+    std::cerr << "WARNING: IPFS client ID has not been set yet. Skip clipboard action." << std::endl;
+  }
+}
+
+/**
+ * \brief Copy IPFS Client public key to clipboard
+ */
+void MainWindow::copy_client_public_key()
+{
+  if (!middleware_.getIPFSClientPublicKey().empty())
+  {
+    get_clipboard("CLIPBOARD")->set_text(middleware_.getIPFSClientPublicKey());
+    showNotification("Copied to clipboard", "Your client public key is now copied to your clipboard.");
+  }
+  else
+  {
+    std::cerr << "WARNING: IPFS client public key has not been set yet. Skip clipboard action." << std::endl;
+  }
+}
+
+/**
+ * \brief Trigger when pressed enter in the search entry
+ */
+void MainWindow::on_search()
+{
+  // Forward search, find and select
+  std::string text = m_searchEntry.get_text();
+  auto buffer = m_draw_main.get_buffer();
+  Gtk::TextBuffer::iterator iter = buffer->get_iter_at_mark(buffer->get_mark("insert"));
+  Gtk::TextBuffer::iterator start, end;
+  bool matchCase = m_searchMatchCase.get_active();
+  Gtk::TextSearchFlags flags = Gtk::TextSearchFlags::TEXT_SEARCH_TEXT_ONLY;
+  if (!matchCase)
+  {
+    flags |= Gtk::TextSearchFlags::TEXT_SEARCH_CASE_INSENSITIVE;
+  }
+  if (iter.forward_search(text, flags, start, end))
+  {
+    buffer->select_range(end, start);
+    m_draw_main.scroll_to(start);
+  }
+  else
+  {
+    buffer->place_cursor(buffer->begin());
+    // Try another search directly from the top
+    Gtk::TextBuffer::iterator secondIter = buffer->get_iter_at_mark(buffer->get_mark("insert"));
+    if (secondIter.forward_search(text, flags, start, end))
+    {
+      buffer->select_range(end, start);
+      m_draw_main.scroll_to(start);
+    }
+  }
+}
+
+/**
+ * \brief Trigger when user pressed enter in the replace entry
+ */
+void MainWindow::on_replace()
+{
+  if (m_draw_main.get_editable())
+  {
+    auto buffer = m_draw_main.get_buffer();
+    Gtk::TextBuffer::iterator startIter = buffer->get_iter_at_mark(buffer->get_mark("insert"));
+    Gtk::TextBuffer::iterator endIter = buffer->get_iter_at_mark(buffer->get_mark("selection_bound"));
+    if (startIter != endIter)
+    {
+      // replace
+      std::string replace = m_searchReplaceEntry.get_text();
+      buffer->begin_user_action();
+      buffer->erase(startIter, endIter);
+      buffer->insert_at_cursor(replace);
+      buffer->end_user_action();
+    }
+    on_search();
+  }
+}
+
+/**
+ * \brief Triggers when pressed enter in the address bar
+ */
+void MainWindow::address_bar_activate()
+{
+  middleware_.doRequest(m_addressBar.get_text(), false);
+  // When user actually entered the address bar, focus on the main draw
+  m_draw_main.grab_focus();
+}
+
+/**
+ * \brief Triggers when user tries to search or replace text
+ */
+void MainWindow::show_search(bool replace)
+{
+  if (m_searchPopover.is_visible() && m_searchReplaceEntry.is_visible())
+  {
+    if (replace)
+    {
+      m_searchPopover.hide();
+      m_addressBar.grab_focus();
+      m_searchReplaceEntry.hide();
+    }
+    else
+    {
+      m_searchEntry.grab_focus();
+      m_searchReplaceEntry.hide();
+    }
+  }
+  else if (m_searchPopover.is_visible())
+  {
+    if (replace)
+    {
+      m_searchReplaceEntry.show();
+    }
+    else
+    {
+      m_searchPopover.hide();
+      m_addressBar.grab_focus();
+      m_searchReplaceEntry.hide();
+    }
+  }
+  else
+  {
+    m_searchPopover.show();
+    m_searchEntry.grab_focus();
+    if (replace)
+    {
+      m_searchReplaceEntry.show();
+    }
+    else
+    {
+      m_searchReplaceEntry.hide();
+    }
+  }
+}
+
+void MainWindow::back()
+{
+  if (currentHistoryIndex_ > 0)
+  {
+    currentHistoryIndex_--;
+    middleware_.doRequest(history_.at(currentHistoryIndex_), true, true);
+  }
+}
+
+void MainWindow::forward()
+{
+  if (currentHistoryIndex_ < history_.size() - 1)
+  {
+    currentHistoryIndex_++;
+    middleware_.doRequest(history_.at(currentHistoryIndex_), true, true);
+  }
+}
+
+/**
+ * \brief Determing if browser is installed to the installation directory at runtime
+ * \return true if the current running process is installed (to the installed prefix path)
+ */
+bool MainWindow::isInstalled()
+{
+  char* path = NULL;
+  int length;
+  length = wai_getExecutablePath(NULL, 0, NULL);
+  if (length > 0)
+  {
+    path = (char*)malloc(length + 1);
+    if (!path)
+    {
+      std::cerr << "ERROR: Couldn't create executable path." << std::endl;
+    }
+    else
+    {
+      bool isInstalled = true;
+      wai_getExecutablePath(path, length, NULL);
+      path[length] = '\0';
+#ifdef _WIN32
+      // Does the executable path starts with C:\Program?
+      const char* windowsPrefix = "C:\\Program";
+      isInstalled = (strncmp(path, windowsPrefix, strlen(windowsPrefix)) == 0);
+#else
+      // Does the executable path starts with /usr/local?
+      isInstalled = (strncmp(path, INSTALL_PREFIX, strlen(INSTALL_PREFIX)) == 0);
+#endif
+      free(path);
+      return isInstalled;
+    }
+  }
+  return true; // fallback; assume always installed
+}
+
+/**
+ * \brief Enable editor mode. Allowing to create or edit existing documents.
+ */
+void MainWindow::enableEdit()
+{
+  // Inform the Draw class that we are creating a new document
+  m_draw_main.newDocument();
+  // Show editor toolbars
+  m_hboxStandardEditorToolbar.show();
+  m_hboxFormattingEditorToolbar.show();
+  // Determine position of divider between the primary and secondary windows
+  int location = 0;
+  int positionSettings = 42;
+  if (m_settings)
+    positionSettings = m_settings->get_int("position-divider");
+  int currentWidth, _ = 0;
+  get_size(currentWidth, _);
+  // If position from settings is still default (42) or too big,
+  // let's calculate the paned divider location
+  if ((positionSettings == 42) || (positionSettings >= (currentWidth - 10)))
+  {
+    location = static_cast<int>(currentWidth / 2.0);
+  }
+  else
+  {
+    location = positionSettings;
+  }
+  m_paned.set_position(location);
+
+  // Enabled secondary text view (on the right)
+  m_scrolledWindowSecondary.show();
+  // Disable "view source" menu item
+  m_draw_main.setViewSourceMenuItem(false);
+  // Connect changed signal
+  textChangedSignalHandler_ = m_draw_main.get_buffer().get()->signal_changed().connect(sigc::mem_fun(this, &MainWindow::editor_changed_text));
+  // Enable publish menu item
+  m_menu.setPublishMenuSensitive(true);
+  // Disable edit menu item (you are already editing)
+  m_menu.setEditMenuSensitive(false);
+  // Just to be sure, disable the spinning animation
+  m_refreshIcon.get_style_context()->remove_class("spinning");
+}
+
+/**
+ * \brief Disable editor mode.
+ */
+void MainWindow::disableEdit()
+{
+  if (isEditorEnabled())
+  {
+    m_hboxStandardEditorToolbar.hide();
+    m_hboxFormattingEditorToolbar.hide();
+    m_scrolledWindowSecondary.hide();
+    // Disconnect text changed signal
+    textChangedSignalHandler_.disconnect();
+    // Show "view source" menu item again
+    m_draw_main.setViewSourceMenuItem(true);
+    m_draw_secondary.clearText();
+    // Disable publish menu item
+    m_menu.setPublishMenuSensitive(false);
+    // Enable edit menu item
+    m_menu.setEditMenuSensitive(true);
+    // Empty current file saved path
+    currentFileSavedPath_ = "";
+  }
+}
+
+/**
+ * \brief Check if editor is enabled
+ * \return true if enabled, otherwise false
+ */
+bool MainWindow::isEditorEnabled()
+{
+  return m_hboxStandardEditorToolbar.is_visible();
+}
+
+/**
+ * \brief Retrieve image path from icon theme location
+ * \param iconName Icon name (.png is added default)
+ * \param typeofIcon Type of the icon is the sub-folder within the icons directory (eg. "editor", "arrows" or "basic")
+ * \return full path of the icon PNG image
+ */
+std::string MainWindow::getIconImageFromTheme(const std::string& iconName, const std::string& typeofIcon)
+{
+  // Use data directory first, used when LibreWeb is installed (Linux or Windows)
+  for (std::string data_dir : Glib::get_system_data_dirs())
+  {
+    std::vector<std::string> path_builder{data_dir, "libreweb", "images", "icons", iconTheme_, typeofIcon, iconName + ".png"};
+    std::string file_path = Glib::build_path(G_DIR_SEPARATOR_S, path_builder);
+    if (Glib::file_test(file_path, Glib::FileTest::FILE_TEST_IS_REGULAR))
+    {
+      return file_path;
+    }
+  }
+
+  // Try local path if the images are not (yet) installed
+  // When working directory is in the build/bin folder (relative path)
+  std::vector<std::string> path_builder{"..", "..", "images", "icons", iconTheme_, typeofIcon, iconName + ".png"};
+  std::string file_path = Glib::build_path(G_DIR_SEPARATOR_S, path_builder);
+  if (Glib::file_test(file_path, Glib::FileTest::FILE_TEST_IS_REGULAR))
+  {
+    return file_path;
+  }
+  else
+  {
+    return "";
+  }
+}
+
+/**
+ * \brief Update the CSS provider data on the main draw text view
+ */
+void MainWindow::updateCSS()
+{
+  std::string colorCss;
+  double darknessScale = (1.0 - brightnessScale_);
+  std::ostringstream darknessDoubleStream;
+  darknessDoubleStream << darknessScale;
+  std::string darknessStr = darknessDoubleStream.str();
+
+  // If it's getting to dark, let's change the font color to white
+  if (darknessScale >= 0.7)
+  {
+    double colorDouble = ((((1.0 - darknessScale) - 0.5) * (20.0 - 255.0)) / (1.0 - 0.5)) + 255.0;
+    std::ostringstream colorStream;
+    colorStream << colorDouble;
+    std::string colorStr = colorStream.str();
+    colorCss = "color: rgba(" + colorStr + ", " + colorStr + ", " + colorStr + ", " + darknessStr + ");";
+  }
+
+  try
+  {
+    m_drawCSSProvider->load_from_data("textview { "
+                                      "font-family: \"" +
+                                      fontFamily_ +
+                                      "\";"
+                                      "font-size: " +
+                                      std::to_string(currentFontSize_) + "pt; }" + "textview text { " + colorCss + "background-color: rgba(0, 0, 0," +
+                                      darknessStr +
+                                      ");"
+                                      "letter-spacing: " +
+                                      std::to_string(fontSpacing_) + "px; }");
+  }
+  catch (const Gtk::CssProviderError& error)
+  {
+    std::cerr << "ERROR: Could not apply CSS format, error: " << error.what() << std::endl;
+  }
+}
+
+/**
+ * \brief Show Gio notification
+ * \param title Title of the notification
+ * \param message The message displayed along with the notificiation
+ */
+void MainWindow::showNotification(const Glib::ustring& title, const Glib::ustring& message)
+{
+  // TODO: Report GLib-CRITICAL upstream to GTK (this is not my issue)
+  auto notification = Gio::Notification::create(title);
+  auto icon = Gio::ThemedIcon::create("dialog-information");
+  notification->set_body(message);
+  notification->set_icon(icon);
+  get_application()->send_notification(notification);
+}
+
+void MainWindow::editor_changed_text()
+{
+  // TODO: Just execute the code below in a signal_idle call?
+  // So it will never block the GUI thread
+
+  // Retrieve text from editor and parse the markdown contents
+  middleware_.setContent(m_draw_main.getText());
+  cmark_node* doc = middleware_.parseContent();
+
+  /* Can be enabled to show the markdown format in terminal:
+  std::string md = Parser::renderMarkdown(doc);
+  std::cout << "Markdown:\n" << md << std::endl;*/
+
+  // Show the document as a preview on the right side text-view panel
+  m_draw_secondary.setDocument(doc);
+}
+
+/**
+ * \brief Show source code dialog window with the current content
+ */
+void MainWindow::show_source_code_dialog()
+{
+  m_sourceCodeDialog.setText(middleware_.getContent());
+  m_sourceCodeDialog.run();
+}
+
+/**
+ * \brief Retrieve selected heading from combobox.
+ * Send to main Draw class
+ */
+void MainWindow::get_heading()
+{
+  std::string active = m_headingsComboBox.get_active_id();
+  m_headingsComboBox.set_active(0); // Reset
+  if (active != "")
+  {
+    std::string::size_type sz;
+    try
+    {
+      int headingLevel = std::stoi(active, &sz, 10);
+      m_draw_main.make_heading(headingLevel);
+    }
+    catch (const std::invalid_argument&)
+    {
+      // ignore
+      std::cerr << "ERROR: heading combobox id is invalid (not a number)." << std::endl;
+    }
+    catch (const std::out_of_range&)
+    {
+      // ignore
+    }
+  }
+}
+
+void MainWindow::insert_emoji()
+{
+  // Note: The "insert-emoji" signal is not exposed in Gtkmm library (at least not in gtk3)
+  g_signal_emit_by_name(m_draw_main.gobj(), "insert-emoji");
+}
+
+void MainWindow::on_zoom_out()
+{
+  currentFontSize_ -= 1;
+  updateCSS();
+  m_zoomRestoreButton.set_sensitive(currentFontSize_ != defaultFontSize_);
+}
+
+void MainWindow::on_zoom_restore()
+{
+  currentFontSize_ = defaultFontSize_; // reset
+  updateCSS();
+  m_zoomRestoreButton.set_sensitive(false);
+}
+
+void MainWindow::on_zoom_in()
+{
+  currentFontSize_ += 1;
+  updateCSS();
+  m_zoomRestoreButton.set_sensitive(currentFontSize_ != defaultFontSize_);
+}
+
+void MainWindow::on_font_set()
+{
+  Pango::FontDescription fontDesc = Pango::FontDescription(m_fontButton.get_font_name());
+  fontFamily_ = fontDesc.get_family();
+  currentFontSize_ = defaultFontSize_ = (fontDesc.get_size_is_absolute()) ? fontDesc.get_size() : fontDesc.get_size() / PANGO_SCALE;
+  updateCSS();
+}
+
+void MainWindow::on_spacing_changed()
+{
+  fontSpacing_ = m_spacingSpinButton.get_value_as_int(); // Letter spacing
+  updateCSS();
+}
+
+void MainWindow::on_margins_changed()
+{
+  m_draw_main.set_left_margin(m_marginsSpinButton.get_value_as_int());
+  m_draw_main.set_right_margin(m_marginsSpinButton.get_value_as_int());
+}
+
+void MainWindow::on_indent_changed()
+{
+  m_draw_main.set_indent(m_indentSpinButton.get_value_as_int());
+}
+
+void MainWindow::on_brightness_changed()
+{
+  brightnessScale_ = m_scaleSettingsBrightness.get_value();
+  updateCSS();
+}
+
+void MainWindow::on_theme_changed()
+{
+  // Switch between dark or light theme preference
+  useDarkTheme_ = m_themeSwitch.get_active();
+  setTheme();
+}
+
+void MainWindow::on_icon_theme_activated(Gtk::ListBoxRow* row)
+{
+  std::string themeName = static_cast<char*>(row->get_data("value"));
+  if (themeName != "none")
+  {
+    iconTheme_ = themeName;
+    useCurrentGTKIconTheme_ = false;
+  }
+  else
+  {
+    useCurrentGTKIconTheme_ = true;
+  }
+  // Reload icons
+  loadIcons();
+  // Trigger IPFS status icon
+  updateStatusPopoverAndIcon();
+}
\ No newline at end of file
diff --git a/src/mainwindow.h b/src/mainwindow.h
new file mode 100644
index 00000000..48fb4fd9
--- /dev/null
+++ b/src/mainwindow.h
@@ -0,0 +1,294 @@
+#ifndef MAINWINDOW_H
+#define MAINWINDOW_H
+
+#include "about.h"
+#include "draw.h"
+#include "menu.h"
+#include "middleware.h"
+#include "source-code-dialog.h"
+
+#include <giomm/settings.h>
+#include <gtkmm/adjustment.h>
+#include <gtkmm/box.h>
+#include <gtkmm/button.h>
+#include <gtkmm/comboboxtext.h>
+#include <gtkmm/cssprovider.h>
+#include <gtkmm/entry.h>
+#include <gtkmm/filechooserdialog.h>
+#include <gtkmm/fontbutton.h>
+#include <gtkmm/grid.h>
+#include <gtkmm/listbox.h>
+#include <gtkmm/menubar.h>
+#include <gtkmm/menubutton.h>
+#include <gtkmm/messagedialog.h>
+#include <gtkmm/modelbutton.h>
+#include <gtkmm/paned.h>
+#include <gtkmm/popover.h>
+#include <gtkmm/popovermenu.h>
+#include <gtkmm/scale.h>
+#include <gtkmm/scrolledwindow.h>
+#include <gtkmm/searchbar.h>
+#include <gtkmm/searchentry.h>
+#include <gtkmm/separator.h>
+#include <gtkmm/spinbutton.h>
+#include <gtkmm/switch.h>
+#include <gtkmm/togglebutton.h>
+#include <gtkmm/window.h>
+#include <sigc++/connection.h>
+
+struct cmark_node;
+
+/**
+ * \class MainWindow
+ * \brief Main Application Window
+ */
+class MainWindow : public Gtk::Window
+{
+public:
+  static const int DEFAULT_FONT_SIZE = 10;
+  explicit MainWindow(const std::string& timeout);
+  void preRequest(const std::string& path, const std::string& title, bool isSetAddressBar, bool isHistoryRequest, bool isDisableEditor);
+  void postWrite(const std::string& path, const std::string& title, bool isSetAddressAndTitle);
+  void startedRequest();
+  void finishedRequest();
+  void refreshRequest();
+  void showStartpage();
+  void setText(const Glib::ustring& content);
+  void setDocument(cmark_node* rootNode);
+  void setMessage(const Glib::ustring& message, const Glib::ustring& details = "");
+  void updateStatusPopoverAndIcon();
+
+protected:
+  // Signal handlers
+  bool delete_window(GdkEventAny* any_event);
+  void cut();
+  void copy();
+  void paste();
+  void del();
+  void selectAll();
+  void new_doc();
+  void open();
+  void open_and_edit();
+  void on_open_dialog_response(int response_id, Gtk::FileChooserDialog* dialog);
+  void on_open_edit_dialog_response(int response_id, Gtk::FileChooserDialog* dialog);
+  void edit();
+  void save();
+  void save_as();
+  void on_save_as_dialog_response(int response_id, Gtk::FileChooserDialog* dialog);
+  void publish();
+  void go_home();
+  void copy_client_id();
+  void copy_client_public_key();
+  void address_bar_activate();
+  void on_search();
+  void on_replace();
+  void show_search(bool replace);
+  void back();
+  void forward();
+  void on_button_clicked(Glib::ustring data);
+  void show_about();
+  void hide_about(int response);
+  void editor_changed_text();
+  void show_source_code_dialog();
+  void get_heading();
+  void insert_emoji();
+  void on_zoom_out();
+  void on_zoom_restore();
+  void on_zoom_in();
+  void on_font_set();
+  void on_spacing_changed();
+  void on_margins_changed();
+  void on_indent_changed();
+  void on_brightness_changed();
+  void on_theme_changed();
+  void on_icon_theme_activated(Gtk::ListBoxRow* row);
+
+  Glib::RefPtr<Gtk::AccelGroup> m_accelGroup;           /*!< Accelerator group, used for keyboard shortcut bindings */
+  Glib::RefPtr<Gio::Settings> m_settings;               /*!< Settings to store our preferences, even during restarts */
+  Glib::RefPtr<Gtk::Adjustment> m_brightnessAdjustment; /*!< Bridghtness adjustment settings */
+  Glib::RefPtr<Gtk::Adjustment> m_spacingAdjustment;    /*!< Spacing adjustment settings */
+  Glib::RefPtr<Gtk::Adjustment> m_marginsAdjustment;    /*!< Margins adjustment settings */
+  Glib::RefPtr<Gtk::Adjustment> m_indentAdjustment;     /*!< Indent adjustment settings */
+  Glib::RefPtr<Gtk::CssProvider> m_drawCSSProvider;     /*!< CSS Provider for draw textviews */
+
+  // Child widgets
+  Menu m_menu;
+  Draw m_draw_main;
+  Draw m_draw_secondary;
+  SourceCodeDialog m_sourceCodeDialog;
+  About m_about;
+  Gtk::HPaned m_paned;
+  Gtk::SearchBar m_search;
+  Gtk::SearchBar m_searchReplace;
+  Gtk::SearchEntry m_searchEntry;
+  Gtk::Entry m_searchReplaceEntry;
+  Gtk::Box m_vbox;
+  Gtk::Box m_hboxBrowserToolbar;
+  Gtk::Box m_hboxStandardEditorToolbar;
+  Gtk::Box m_hboxFormattingEditorToolbar;
+  Gtk::Box m_hboxSearch;
+  Gtk::Box m_vboxSearch;
+  Gtk::Box m_vboxStatus;
+  Gtk::Box m_vboxSettings;
+  Gtk::Box m_hboxSetingsZoom;
+  Gtk::Box m_hboxSetingsBrightness;
+  Gtk::Box m_vboxIconTheme;
+  Gtk::ScrolledWindow m_iconThemeListScrolledWindow;
+  Gtk::ListBox m_iconThemeListBox;
+  Gtk::Scale m_scaleSettingsBrightness;
+  Gtk::Entry m_addressBar;
+  Gtk::ToggleButton m_searchMatchCase;
+  Gtk::Button m_zoomOutButton;
+  Gtk::Button m_zoomRestoreButton;
+  Gtk::Button m_zoomInButton;
+  Gtk::FontButton m_fontButton;
+  Gtk::SpinButton m_spacingSpinButton;
+  Gtk::SpinButton m_marginsSpinButton;
+  Gtk::SpinButton m_indentSpinButton;
+  Gtk::ModelButton m_iconThemeButton;
+  Gtk::ModelButton m_aboutButton;
+  Gtk::ModelButton m_iconThemeBackButton;
+  Gtk::Grid m_statusGrid;
+  Gtk::Grid m_activityStatusGrid;
+  Gtk::Grid m_settingsGrid;
+  Gtk::Button m_backButton;
+  Gtk::Button m_forwardButton;
+  Gtk::Button m_refreshButton;
+  Gtk::Button m_homeButton;
+  Gtk::MenuButton m_searchButton;
+  Gtk::MenuButton m_statusButton;
+  Gtk::MenuButton m_settingsButton;
+  Gtk::Button m_openButton;
+  Gtk::Button m_saveButton;
+  Gtk::Button m_publishButton;
+  Gtk::Button m_cutButton;
+  Gtk::Button m_copyButton;
+  Gtk::Button m_pasteButton;
+  Gtk::Button m_undoButton;
+  Gtk::Button m_redoButton;
+  Gtk::ComboBoxText m_headingsComboBox;
+  Gtk::Button m_boldButton;
+  Gtk::Button m_italicButton;
+  Gtk::Button m_strikethroughButton;
+  Gtk::Button m_superButton;
+  Gtk::Button m_subButton;
+  Gtk::Button m_linkButton;
+  Gtk::Button m_imageButton;
+  Gtk::Button m_emojiButton;
+  Gtk::Button m_quoteButton;
+  Gtk::Button m_codeButton;
+  Gtk::Button m_bulletListButton;
+  Gtk::Button m_numberedListButton;
+  Gtk::Button m_highlightButton;
+  Gtk::Image m_zoomOutImage;
+  Gtk::Image m_zoomInImage;
+  Gtk::Image m_brightnessImage;
+  Gtk::Image m_backIcon;
+  Gtk::Image m_forwardIcon;
+  Gtk::Image m_refreshIcon;
+  Gtk::Image m_homeIcon;
+  Gtk::Image m_searchIcon;
+  Gtk::Image m_statusIcon;
+  Glib::RefPtr<Gdk::Pixbuf> m_statusOfflineIcon;
+  Glib::RefPtr<Gdk::Pixbuf> m_statusOnlineIcon;
+  Gtk::Image m_settingsIcon;
+  Gtk::Image m_openIcon;
+  Gtk::Image m_saveIcon;
+  Gtk::Image m_publishIcon;
+  Gtk::Image m_cutIcon;
+  Gtk::Image m_copyIcon;
+  Gtk::Image m_pasteIcon;
+  Gtk::Image m_undoIcon;
+  Gtk::Image m_redoIcon;
+  Gtk::Image m_boldIcon;
+  Gtk::Image m_italicIcon;
+  Gtk::Image m_strikethroughIcon;
+  Gtk::Image m_superIcon;
+  Gtk::Image m_subIcon;
+  Gtk::Image m_linkIcon;
+  Gtk::Image m_imageIcon;
+  Gtk::Image m_emojiIcon;
+  Gtk::Image m_quoteIcon;
+  Gtk::Image m_codeIcon;
+  Gtk::Image m_bulletListIcon;
+  Gtk::Image m_numberedListIcon;
+  Gtk::Image m_hightlightIcon;
+  Gtk::Popover m_searchPopover;
+  Gtk::Popover m_statusPopover;
+  Gtk::PopoverMenu m_settingsPopover;
+  Gtk::ModelButton m_copyIDButton;
+  Gtk::ModelButton m_copyPublicKeyButton;
+  Gtk::Switch m_themeSwitch;
+  Gtk::Label m_networkHeadingLabel;
+  Gtk::Label m_networkRateHeadingLabel;
+  Gtk::Label m_connectivityLabel;
+  Gtk::Label m_connectivityStatusLabel;
+  Gtk::Label m_peersLabel;
+  Gtk::Label m_peersStatusLabel;
+  Gtk::Label m_repoSizeLabel;
+  Gtk::Label m_repoSizeStatusLabel;
+  Gtk::Label m_repoPathLabel;
+  Gtk::Label m_repoPathStatusLabel;
+  Gtk::Label m_ipfsVersionLabel;
+  Gtk::Label m_ipfsVersionStatusLabel;
+  Gtk::Label m_networkIncomingLabel;
+  Gtk::Label m_networkIncomingStatusLabel;
+  Gtk::Label m_networkOutcomingLabel;
+  Gtk::Label m_networkOutcomingStatusLabel;
+  Gtk::Label m_networkKiloBytesLabel;
+  Gtk::Label m_fontLabel;
+  Gtk::Label m_spacingLabel;
+  Gtk::Label m_marginsLabel;
+  Gtk::Label m_indentLabel;
+  Gtk::Label m_themeLabel;
+  Gtk::Label m_iconThemeLabel;
+  std::unique_ptr<Gtk::MessageDialog> m_contentPublishedDialog;
+  Gtk::ScrolledWindow m_scrolledWindowMain;
+  Gtk::ScrolledWindow m_scrolledWindowSecondary;
+  Gtk::SeparatorMenuItem m_separator1;
+  Gtk::SeparatorMenuItem m_separator2;
+  Gtk::SeparatorMenuItem m_separator3;
+  Gtk::SeparatorMenuItem m_separator4;
+  Gtk::Separator m_separator5;
+  Gtk::Separator m_separator6;
+  Gtk::Separator m_separator7;
+  Gtk::Separator m_separator8;
+  Gtk::Separator m_separator9;
+  Gtk::Separator m_separator10;
+
+private:
+  Middleware middleware_;
+  std::string appName_;
+  bool useCurrentGTKIconTheme_;
+  std::string iconTheme_;
+  int iconSize_;
+  std::string fontFamily_;
+  int defaultFontSize_;
+  int currentFontSize_;
+  int fontSpacing_;
+  double brightnessScale_;
+  bool useDarkTheme_;
+  std::string currentFileSavedPath_;
+  std::size_t currentHistoryIndex_;
+  std::vector<std::string> history_;
+  sigc::connection textChangedSignalHandler_;
+
+  void loadStoredSettings();
+  void setGTKIcons();
+  void loadIcons();
+  void initButtons();
+  void setTheme();
+  void initSearchPopover();
+  void initStatusPopover();
+  void initSettingsPopover();
+  void initSignals();
+  bool isInstalled();
+  void enableEdit();
+  void disableEdit();
+  bool isEditorEnabled();
+  std::string getIconImageFromTheme(const std::string& iconName, const std::string& typeofIcon);
+  void updateCSS();
+  void showNotification(const Glib::ustring& title, const Glib::ustring& message = "");
+};
+
+#endif
diff --git a/src/md-parser.cc b/src/md-parser.cc
new file mode 100644
index 00000000..7a57d15a
--- /dev/null
+++ b/src/md-parser.cc
@@ -0,0 +1,86 @@
+#include "md-parser.h"
+
+#include <cmark-gfm-core-extensions.h>
+#include <filesystem>
+#include <node.h>
+#include <stdexcept>
+#include <syntax_extension.h>
+
+static const int OPTIONS = CMARK_OPT_STRIKETHROUGH_DOUBLE_TILDE;
+
+/// Meyers Singleton
+Parser::Parser() = default;
+/// Destructor
+Parser::~Parser() = default;
+
+/**
+ * \brief Get singleton instance
+ * \return Helper reference (singleton)
+ */
+Parser& Parser::getInstance()
+{
+  static Parser instance;
+  return instance;
+}
+
+/**
+ * \brief Parse markdown file from string content.
+ * Note: Do not forgot to execute: cmark_node_free(document); when you are done with the doc.
+ * \param content Content as string
+ * \return AST structure (of type cmark_node)
+ */
+cmark_node* Parser::parseContent(const Glib::ustring& content)
+{
+  const char* data = content.c_str();
+
+  cmark_gfm_core_extensions_ensure_registered();
+
+  // Modified version of cmark_parse_document() in blocks.c
+  cmark_parser* parser = cmark_parser_new(OPTIONS);
+  cmark_node* document;
+  // Add extensions
+  addMarkdownExtension(parser, "strikethrough");
+  addMarkdownExtension(parser, "highlight");
+  addMarkdownExtension(parser, "superscript");
+  addMarkdownExtension(parser, "subscript");
+  // addMarkdownExtension(parser, "table");
+
+  cmark_parser_feed(parser, data, strlen(data));
+  document = cmark_parser_finish(parser);
+  cmark_parser_free(parser);
+  return document;
+}
+
+/**
+ * \brief Built-in cmark parser to HTML
+ * \return HTML as string
+ */
+Glib::ustring Parser::renderHTML(cmark_node* node)
+{
+  char* tmp = cmark_render_html(node, OPTIONS, NULL);
+  Glib::ustring output = Glib::ustring(tmp);
+  free(tmp);
+  return output;
+}
+
+/**
+ * \brief Built-in cmark parser to markdown (again)
+ * \return return markdown as string
+ */
+Glib::ustring Parser::renderMarkdown(cmark_node* node)
+{
+  char* tmp = cmark_render_commonmark(node, OPTIONS, 600);
+  Glib::ustring output = Glib::ustring(tmp);
+  free(tmp);
+  return output;
+}
+
+/**
+ * This is a function that will make enabling extensions easier
+ */
+void Parser::addMarkdownExtension(cmark_parser* parser, const char* extName)
+{
+  cmark_syntax_extension* ext = cmark_find_syntax_extension(extName);
+  if (ext)
+    cmark_parser_attach_syntax_extension(parser, ext);
+}
diff --git a/src/md-parser.h b/src/md-parser.h
new file mode 100644
index 00000000..ed7f0aa9
--- /dev/null
+++ b/src/md-parser.h
@@ -0,0 +1,30 @@
+#ifndef MD_PARSER_H
+#define MD_PARSER_H
+
+#include <cmark-gfm.h>
+#include <glibmm/ustring.h>
+#include <render.h>
+#include <sstream>
+
+/**
+ * \class Parser
+ * \brief Parser Markdown parser class, parse the content to an AST model
+ */
+class Parser
+{
+public:
+  // Singleton
+  static Parser& getInstance();
+  static cmark_node* parseContent(const Glib::ustring& content);
+  static Glib::ustring renderHTML(cmark_node* node);
+  static Glib::ustring renderMarkdown(cmark_node* node);
+
+private:
+  Parser();
+  ~Parser();
+  Parser(const Parser&) = delete;
+  Parser& operator=(const Parser&) = delete;
+
+  static void addMarkdownExtension(cmark_parser* parser, const char* extName);
+};
+#endif
diff --git a/src/menu.cc b/src/menu.cc
new file mode 100644
index 00000000..8916bf4a
--- /dev/null
+++ b/src/menu.cc
@@ -0,0 +1,164 @@
+#include "menu.h"
+
+Menu::Menu(const Glib::RefPtr<Gtk::AccelGroup>& accelgroup)
+    : m_file("_File", true),
+      m_edit("_Edit", true),
+      m_view("_View", true),
+      m_help("_Help", true)
+{
+  // File sub-menu
+  auto newDocumentMenuItem = createMenuItem("_New Document");
+  newDocumentMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_N, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  newDocumentMenuItem->signal_activate().connect(new_doc);
+  auto openMenuItem = createMenuItem("_Open...");
+  openMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_O, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  openMenuItem->signal_activate().connect(open);
+  auto openEditMenuItem = createMenuItem("Open & _Edit...");
+  openEditMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_E, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  openEditMenuItem->signal_activate().connect(open_edit);
+  editMenuItem = createMenuItem("Edit");
+  editMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_D, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  editMenuItem->signal_activate().connect(edit);
+  auto saveMenuitem = createMenuItem("_Save");
+  saveMenuitem->add_accelerator("activate", accelgroup, GDK_KEY_S, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  saveMenuitem->signal_activate().connect(save);
+  auto saveAsMenuItem = createMenuItem("Save _As...");
+  saveAsMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_S, Gdk::ModifierType::CONTROL_MASK | Gdk::ModifierType::SHIFT_MASK,
+                                  Gtk::AccelFlags::ACCEL_VISIBLE);
+  saveAsMenuItem->signal_activate().connect(save_as);
+  publishMenuItem = createMenuItem("_Publish...");
+  publishMenuItem->set_sensitive(false); // disable
+  publishMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_P, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  publishMenuItem->signal_activate().connect(publish);
+  auto quitMenuItem = createMenuItem("_Quit");
+  quitMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_Q, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  quitMenuItem->signal_activate().connect(quit);
+
+  // Edit sub-menu
+  auto undoMenuItem = createMenuItem("_Undo");
+  undoMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_Z, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  undoMenuItem->signal_activate().connect(undo);
+  auto redoMenuItem = createMenuItem("_Redo");
+  redoMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_Y, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  redoMenuItem->signal_activate().connect(redo);
+  auto cutMenuItem = createMenuItem("Cu_t");
+  cutMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_X, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  cutMenuItem->signal_activate().connect(cut);
+  auto copyMenuItem = createMenuItem("_Copy");
+  copyMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_C, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  copyMenuItem->signal_activate().connect(copy);
+  auto pasteMenuItem = createMenuItem("_Paste");
+  pasteMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_V, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  pasteMenuItem->signal_activate().connect(paste);
+  auto deleteMenuItem = createMenuItem("_Delete");
+  deleteMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_Delete, (Gdk::ModifierType)0, Gtk::AccelFlags::ACCEL_VISIBLE);
+  deleteMenuItem->signal_activate().connect(del);
+  auto selectAllMenuItem = createMenuItem("Select _All");
+  selectAllMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_A, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  selectAllMenuItem->signal_activate().connect(select_all);
+  auto findMenuItem = createMenuItem("_Find");
+  findMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_F, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  findMenuItem->signal_activate().connect(find);
+  auto replaceMenuItem = createMenuItem("_Replace");
+  replaceMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_H, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  replaceMenuItem->signal_activate().connect(replace);
+
+  // View sub-menu
+  backMenuItem = createMenuItem("_Previous Page");
+  backMenuItem->set_sensitive(false);
+  backMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_Left, Gdk::ModifierType::MOD1_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  backMenuItem->signal_activate().connect(back);
+  forwardMenuItem = createMenuItem("_Next page");
+  forwardMenuItem->set_sensitive(false);
+  forwardMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_Right, Gdk::ModifierType::MOD1_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  forwardMenuItem->signal_activate().connect(forward);
+  auto reloadMenuItem = createMenuItem("_Reload Page");
+  reloadMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_R, Gdk::ModifierType::CONTROL_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  reloadMenuItem->signal_activate().connect(reload);
+  auto homePageMenuItem = createMenuItem("_Homepage");
+  homePageMenuItem->add_accelerator("activate", accelgroup, GDK_KEY_Home, Gdk::ModifierType::MOD1_MASK, Gtk::AccelFlags::ACCEL_VISIBLE);
+  homePageMenuItem->signal_activate().connect(home);
+  auto sourceCodeMenuItem = createMenuItem("View _Source");
+  sourceCodeMenuItem->signal_activate().connect(source_code);
+
+  // Help subm-enu
+  auto aboutMenuItem = createMenuItem("_About");
+  aboutMenuItem->signal_activate().connect(about);
+
+  // Add items to sub-menus
+  m_fileSubmenu.append(*newDocumentMenuItem);
+  m_fileSubmenu.append(*openMenuItem);
+  m_fileSubmenu.append(*openEditMenuItem);
+  m_fileSubmenu.append(*editMenuItem);
+  m_fileSubmenu.append(m_separator1);
+  m_fileSubmenu.append(*saveMenuitem);
+  m_fileSubmenu.append(*saveAsMenuItem);
+  m_fileSubmenu.append(m_separator2);
+  m_fileSubmenu.append(*publishMenuItem);
+  m_fileSubmenu.append(m_separator3);
+  m_fileSubmenu.append(*quitMenuItem);
+  m_editSubmenu.append(*undoMenuItem);
+  m_editSubmenu.append(*redoMenuItem);
+  m_editSubmenu.append(m_separator4);
+  m_editSubmenu.append(*cutMenuItem);
+  m_editSubmenu.append(*copyMenuItem);
+  m_editSubmenu.append(*pasteMenuItem);
+  m_editSubmenu.append(*deleteMenuItem);
+  m_editSubmenu.append(m_separator5);
+  m_editSubmenu.append(*selectAllMenuItem);
+  m_editSubmenu.append(m_separator6);
+  m_editSubmenu.append(*findMenuItem);
+  m_editSubmenu.append(*replaceMenuItem);
+  m_viewSubmenu.append(*backMenuItem);
+  m_viewSubmenu.append(*forwardMenuItem);
+  m_viewSubmenu.append(*reloadMenuItem);
+  m_viewSubmenu.append(*homePageMenuItem);
+  m_viewSubmenu.append(m_separator7);
+  m_viewSubmenu.append(*sourceCodeMenuItem);
+  m_helpSubmenu.append(*aboutMenuItem);
+
+  // Add sub-menus to menus
+  m_file.set_submenu(m_fileSubmenu);
+  m_edit.set_submenu(m_editSubmenu);
+  m_view.set_submenu(m_viewSubmenu);
+  m_help.set_submenu(m_helpSubmenu);
+  // Add menus to menu bar
+  append(m_file);
+  append(m_edit);
+  append(m_view);
+  append(m_help);
+}
+
+Menu::~Menu()
+{
+}
+
+void Menu::setBackMenuSensitive(bool sensitive)
+{
+  backMenuItem->set_sensitive(sensitive);
+}
+
+void Menu::setForwardMenuSensitive(bool sensitive)
+{
+  forwardMenuItem->set_sensitive(sensitive);
+}
+
+void Menu::setPublishMenuSensitive(bool sensitive)
+{
+  publishMenuItem->set_sensitive(sensitive);
+}
+
+void Menu::setEditMenuSensitive(bool sensitive)
+{
+  editMenuItem->set_sensitive(sensitive);
+}
+
+/**
+ * \brief Helper method for creating a menu with an image
+ * \return GTKWidget menu item pointer
+ */
+Gtk::MenuItem* Menu::createMenuItem(const Glib::ustring& label_text)
+{
+  Gtk::MenuItem* item = Gtk::manage(new Gtk::MenuItem(label_text, true));
+  return item;
+}
diff --git a/src/menu.h b/src/menu.h
new file mode 100644
index 00000000..4100d27f
--- /dev/null
+++ b/src/menu.h
@@ -0,0 +1,73 @@
+#ifndef MENU_H
+#define MENU_H
+
+#include <gtkmm/menu.h>
+#include <gtkmm/menubar.h>
+#include <gtkmm/menuitem.h>
+#include <gtkmm/separatormenuitem.h>
+#include <signal.h>
+
+/**
+ * \class Menu
+ * \brief The top main-menu
+ */
+class Menu : public Gtk::MenuBar
+{
+public:
+  sigc::signal<void> new_doc;
+  sigc::signal<void> open;
+  sigc::signal<void> open_edit;
+  sigc::signal<void> edit;
+  sigc::signal<void> save;
+  sigc::signal<void> save_as;
+  sigc::signal<void> publish;
+  sigc::signal<void> quit;
+  sigc::signal<void> undo;
+  sigc::signal<void> redo;
+  sigc::signal<void> cut;
+  sigc::signal<void> copy;
+  sigc::signal<void> paste;
+  sigc::signal<void> del;
+  sigc::signal<void> select_all;
+  sigc::signal<void> find;
+  sigc::signal<void> replace;
+  sigc::signal<void> back;
+  sigc::signal<void> forward;
+  sigc::signal<void> reload;
+  sigc::signal<void> home;
+  sigc::signal<void> source_code;
+  sigc::signal<void> about;
+
+  explicit Menu(const Glib::RefPtr<Gtk::AccelGroup>& accelgroup);
+  virtual ~Menu();
+  void setBackMenuSensitive(bool sensitive);
+  void setForwardMenuSensitive(bool sensitive);
+  void setPublishMenuSensitive(bool sensitive);
+  void setEditMenuSensitive(bool sensitive);
+
+protected:
+  // Child widgets
+  Gtk::MenuItem m_file;
+  Gtk::MenuItem m_edit;
+  Gtk::MenuItem m_view;
+  Gtk::MenuItem m_help;
+  Gtk::Menu m_fileSubmenu; /*!< File sub menu */
+  Gtk::Menu m_editSubmenu; /*!< Edit sub menu */
+  Gtk::Menu m_viewSubmenu; /*!< View sub menu */
+  Gtk::Menu m_helpSubmenu; /*!< Help sub menu */
+  Gtk::SeparatorMenuItem m_separator1;
+  Gtk::SeparatorMenuItem m_separator2;
+  Gtk::SeparatorMenuItem m_separator3;
+  Gtk::SeparatorMenuItem m_separator4;
+  Gtk::SeparatorMenuItem m_separator5;
+  Gtk::SeparatorMenuItem m_separator6;
+  Gtk::SeparatorMenuItem m_separator7;
+
+private:
+  Gtk::MenuItem* createMenuItem(const Glib::ustring& label_text);
+  Gtk::MenuItem* backMenuItem;
+  Gtk::MenuItem* forwardMenuItem;
+  Gtk::MenuItem* publishMenuItem;
+  Gtk::MenuItem* editMenuItem;
+};
+#endif
\ No newline at end of file
diff --git a/src/middleware.cc b/src/middleware.cc
new file mode 100644
index 00000000..6f34cf47
--- /dev/null
+++ b/src/middleware.cc
@@ -0,0 +1,580 @@
+#include "middleware.h"
+
+#include "file.h"
+#include "mainwindow.h"
+#include "md-parser.h"
+#include <cmark-gfm.h>
+#include <glibmm.h>
+#include <glibmm/main.h>
+
+/**
+ * Middleware constructor
+ */
+Middleware::Middleware(MainWindow& mainWindow, const std::string& timeout)
+    : mainWindow(mainWindow),
+      // Threading:
+      requestThread_(nullptr),
+      statusThread_(nullptr),
+      is_request_thread_done_(false),
+      keep_request_thread_running_(true),
+      is_status_thread_done_(false),
+      // IPFS:
+      ipfsHost_("localhost"),
+      ipfsPort_(5001),
+      ipfsTimeout_(timeout),
+      ipfs_fetch_(ipfsHost_, ipfsPort_, ipfsTimeout_),
+      ipfs_status_(ipfsHost_, ipfsPort_, ipfsTimeout_),
+      ipfsNumberOfPeers_(0),
+      ipfsRepoSize_(0),
+      ipfsIncomingRate_("0.0"),
+      ipfsOutcomingRate_("0.0"),
+      // Request & Response:
+      waitPageVisible_(false)
+{
+  // Hook up signals to Main Window methods
+  requestStarted_.connect(sigc::mem_fun(mainWindow, &MainWindow::startedRequest));
+  requestFinished_.connect(sigc::mem_fun(mainWindow, &MainWindow::finishedRequest));
+
+  // First update status manually (with slight delay), after that the timer below will take care of updates
+  Glib::signal_timeout().connect_once(sigc::mem_fun(this, &Middleware::doIPFSStatusUpdateOnce), 550);
+
+  // Create a timer, triggers every 4 seconds
+  statusTimerHandler_ = Glib::signal_timeout().connect_seconds(sigc::mem_fun(this, &Middleware::doIPFSStatusUpdate), 4);
+}
+
+/**
+ * Destructor
+ */
+Middleware::~Middleware()
+{
+  statusTimerHandler_.disconnect();
+  abortRequest();
+  abortStatus();
+}
+
+/**
+ * Fetch document from disk or IPFS, using threading
+ * \param path File path that needs to be opened (either from disk or IPFS network)
+ * \param isSetAddressBar If true update the address bar with the file path (default: true)
+ * \param isHistoryRequest Set to true if this is an history request call: back/forward (default: false)
+ * \param isDisableEditor If true the editor will be disabled if needed (default: true)
+ * \param isParseContent If true the content received will be parsed and displayed as markdown syntax (default: true),
+ * set to false if you want to editor the content
+ */
+void Middleware::doRequest(const std::string& path, bool isSetAddressBar, bool isHistoryRequest, bool isDisableEditor, bool isParseContent)
+{
+  // Stop any on-going request first, if applicable
+  abortRequest();
+
+  if (requestThread_ == nullptr)
+  {
+    std::string title;
+    if (path.empty() && requestPath_.starts_with("file://"))
+    {
+      title = File::getFilename(requestPath_); // During refresh
+    }
+    else if (path.starts_with("file://"))
+    {
+      title = File::getFilename(path);
+    }
+    // Update main window widgets
+    mainWindow.preRequest(path, title, isSetAddressBar, isHistoryRequest, isDisableEditor);
+
+    // Start thread
+    requestThread_ = new std::thread(&Middleware::processRequest, this, path, isParseContent);
+  }
+  else
+  {
+    std::cerr << "ERROR: Could not start request thread. Something went wrong." << std::endl;
+  }
+}
+
+/**
+ * \brief Add current content to IPFS
+ * \param path file path in IPFS
+ * \return Content identifier (CID)
+ */
+std::string Middleware::doAdd(const std::string& path)
+{
+  // TODO: We should run this within a seperate thread, to avoid blocking the main thread.
+  // See also the other status calls we are making, but maybe we should use ipfs_fetch_ anyway.
+  return ipfs_status_.add(path, getContent());
+}
+
+/**
+ * \brief Write file to disk
+ * \param path file path to disk
+ * \param isSetAddressAndTitle If true update the address bar & title (default: true)
+ */
+void Middleware::doWrite(const std::string& path, bool isSetAddressAndTitle)
+{
+  File::write(path, getContent());
+  mainWindow.postWrite("file://" + path, File::getFilename(path), isSetAddressAndTitle);
+}
+
+/**
+ * \brief Set current plain-text content (not parsed)
+ */
+void Middleware::setContent(const Glib::ustring& content)
+{
+  currentContent_ = content;
+}
+
+/**
+ * \brief Get current plain content (not parsed)
+ * \return content as string
+ */
+Glib::ustring Middleware::getContent() const
+{
+  return currentContent_;
+}
+
+/**
+ * \brief Current content parser middleware
+ * \return AST structure (of type cmark_node)
+ */
+cmark_node* Middleware::parseContent() const
+{
+  return Parser::parseContent(currentContent_);
+}
+
+/**
+ * \brief Reset state
+ */
+void Middleware::resetContentAndPath()
+{
+  currentContent_ = "";
+  requestPath_ = "";
+  finalRequestPath_ = "";
+}
+
+/**
+ * \brief Get IPFS number of peers
+ * \return number of peers (size_t)
+ */
+std::size_t Middleware::getIPFSNumberOfPeers() const
+{
+  return ipfsNumberOfPeers_;
+}
+
+/**
+ * \brief Get IPFS repository size
+ * \return repo size (int)
+ */
+int Middleware::getIPFSRepoSize() const
+{
+  return ipfsRepoSize_;
+}
+
+/**
+ * \brief Get IPFS repository path
+ * \return repo path (string)
+ */
+std::string Middleware::getIPFSRepoPath() const
+{
+  return ipfsRepoPath_;
+}
+
+/**
+ * \brief Get IPFS Incoming rate
+ * \return incoming rate (string)
+ */
+std::string Middleware::getIPFSIncomingRate() const
+{
+  return ipfsIncomingRate_;
+}
+
+/**
+ * \brief Get IPFS Outgoing rate
+ * \return outgoing rate (string)
+ */
+std::string Middleware::getIPFSOutcomingRate() const
+{
+  return ipfsOutcomingRate_;
+}
+
+/**
+ * \brief Get IPFS version
+ * \return version (string)
+ */
+std::string Middleware::getIPFSVersion() const
+{
+  return ipfsVersion_;
+}
+
+/**
+ * \brief Get IPFS Client ID
+ * \return client ID (string)
+ */
+std::string Middleware::getIPFSClientId() const
+{
+  return ipfsClientID_;
+}
+
+/**
+ * \brief Get IPFS Client Public key
+ * \return public key (string)
+ */
+std::string Middleware::getIPFSClientPublicKey() const
+{
+  return ipfsClientPublicKey_;
+}
+
+/************************************************
+ * Private methods
+ ************************************************/
+
+/**
+ * \brief Get the file from disk or IPFS network, from the provided path,
+ * parse the content, and display the document.
+ * Call this method with empty path, will use the previous requestPath_ (thus refresh).
+ * \param path File path that needs to be fetched (from disk or IPFS network)
+ * \param isParseContent Set to true if you want to parse and display the content as markdown syntax (from disk or IPFS
+ * network), set to false if you want to edit the content
+ */
+void Middleware::processRequest(const std::string& path, bool isParseContent)
+{
+  requestStarted_.emit(); // Emit started for Main Window
+  // Reset private variables
+  currentContent_ = "";
+  waitPageVisible_ = false;
+
+  // Do not update the requestPath_ when path is empty,
+  // this is used for refreshing the page
+  if (!path.empty())
+  {
+    requestPath_ = path;
+  }
+
+  if (requestPath_.empty())
+  {
+    std::cerr << "Info: Empty request path." << std::endl;
+  }
+  // Handle homepage
+  else if (requestPath_.compare("about:home") == 0)
+  {
+    Glib::signal_idle().connect_once(sigc::mem_fun(mainWindow, &MainWindow::showStartpage));
+  }
+  // Handle disk or IPFS file paths
+  else
+  {
+    // Check if CID
+    if (requestPath_.starts_with("ipfs://"))
+    {
+      finalRequestPath_ = requestPath_;
+      finalRequestPath_.erase(0, 7);
+      fetchFromIPFS(isParseContent);
+    }
+    else if ((requestPath_.length() == 46) && requestPath_.starts_with("Qm"))
+    {
+      // CIDv0
+      finalRequestPath_ = requestPath_;
+      fetchFromIPFS(isParseContent);
+    }
+    else if (requestPath_.starts_with("file://"))
+    {
+      finalRequestPath_ = requestPath_;
+      finalRequestPath_.erase(0, 7);
+      openFromDisk(isParseContent);
+    }
+    else
+    {
+      // IPFS as fallback / CIDv1
+      finalRequestPath_ = requestPath_;
+      fetchFromIPFS(isParseContent);
+    }
+  }
+
+  requestFinished_.emit();        // Emit finished for Main Window
+  is_request_thread_done_ = true; // mark thread as done
+}
+
+/**
+ * \brief Helper method for processRequest(), display markdown file from IPFS network.
+ * Runs in a seperate thread.
+ * \param isParseContent Set to true if you want to parse and display the content as markdown syntax (from disk or IPFS
+ * network), set to false if you want to edit the content
+ */
+void Middleware::fetchFromIPFS(bool isParseContent)
+{
+  try
+  {
+    std::stringstream contents;
+    ipfs_fetch_.fetch(finalRequestPath_, &contents);
+    // If the thread stops, don't brother to parse the file/update the GTK window
+    if (keep_request_thread_running_)
+    {
+      // Retrieve content to string
+      Glib::ustring content = contents.str();
+      // Only set content if valid UTF-8
+      if (validateUTF8(content) && keep_request_thread_running_)
+      {
+        setContent(content);
+        if (isParseContent)
+        {
+          // TODO: Maybe we want to abort the parser when keep_request_thread_running_ = false,
+          // depending time the parser is taking?
+          cmark_node* doc = parseContent();
+          Glib::signal_idle().connect_once(sigc::bind(sigc::mem_fun(mainWindow, &MainWindow::setDocument), doc));
+        }
+        else
+        {
+          // Directly display the plain markdown content
+          Glib::signal_idle().connect_once(sigc::bind(sigc::mem_fun(mainWindow, &MainWindow::setText), getContent()));
+        }
+      }
+      else
+      {
+        Glib::signal_idle().connect_once(sigc::bind(sigc::mem_fun(mainWindow, &MainWindow::setMessage), "üòµ File will not be displayed ",
+                                                    "File is not valid UTF-8 encoded, like a markdown or text file."));
+      }
+    }
+  }
+  catch (const std::runtime_error& error)
+  {
+    std::string errorMessage = std::string(error.what());
+    // Ignore error reporting when the request was aborted
+    if (errorMessage != "Request was aborted")
+    {
+      std::cerr << "ERROR: IPFS request failed, with message: " << errorMessage << std::endl;
+      if (errorMessage.starts_with("HTTP request failed with status code"))
+      {
+        std::string message;
+        // Remove text until ':\n'
+        errorMessage.erase(0, errorMessage.find(':') + 2);
+        if (!errorMessage.empty() && errorMessage != "")
+        {
+          try
+          {
+            auto content = nlohmann::json::parse(errorMessage);
+            message = "Message: " + content.value("Message", "");
+            if (message.starts_with("context deadline exceeded"))
+            {
+              message += ". Time-out is set to: " + ipfsTimeout_;
+            }
+            message += ".\n\n";
+          }
+          catch (const nlohmann::json::parse_error& parseError)
+          {
+            std::cerr << "ERROR: Could not parse at byte: " << parseError.byte << std::endl;
+          }
+        }
+        Glib::signal_idle().connect_once(sigc::bind(sigc::mem_fun(mainWindow, &MainWindow::setMessage), "üéÇ We're having trouble finding this site.",
+                                                    message + "You could try to reload the page or try increase the time-out (see --help)."));
+      }
+      else if (errorMessage.starts_with("Couldn't connect to server: Failed to connect to localhost"))
+      {
+        Glib::signal_idle().connect_once(sigc::bind(sigc::mem_fun(mainWindow, &MainWindow::setMessage), "‚åõ Please wait...",
+                                                    "IPFS daemon is still spinnng-up, page will automatically refresh..."));
+        waitPageVisible_ = true; // Please wait page is shown (auto-refresh when network is up)
+      }
+      else
+      {
+        Glib::signal_idle().connect_once(
+            sigc::bind(sigc::mem_fun(mainWindow, &MainWindow::setMessage), "‚ùå Something went wrong", "Error message: " + std::string(error.what())));
+      }
+    }
+  }
+}
+
+/**
+ * \brief Helper method for processRequest(), display markdown file from disk.
+ * Runs in a seperate thread.
+ * \param isParseContent Set to true if you want to parse and display the content as markdown syntax (from disk or IPFS
+ * network), set to false if you want to edit the content
+ */
+void Middleware::openFromDisk(bool isParseContent)
+{
+  try
+  {
+    // TODO: Abort file read if keep_request_thread_running_ = false and throw runtime error, to stop futher execution
+    // eg. when you are reading a very big file from disk.
+    const Glib::ustring content = File::read(finalRequestPath_);
+    // If the thread stops, don't brother to parse the file/update the GTK window
+    if (keep_request_thread_running_)
+    {
+      // Only set content if valid UTF-8
+      if (validateUTF8(content))
+      {
+        setContent(content);
+        if (isParseContent)
+        {
+          cmark_node* doc = parseContent();
+          Glib::signal_idle().connect_once(sigc::bind(sigc::mem_fun(mainWindow, &MainWindow::setDocument), doc));
+        }
+        else
+        {
+          // Directly set the plain markdown content
+          Glib::signal_idle().connect_once(sigc::bind(sigc::mem_fun(mainWindow, &MainWindow::setText), getContent()));
+        }
+      }
+      else
+      {
+        Glib::signal_idle().connect_once(sigc::bind(sigc::mem_fun(mainWindow, &MainWindow::setMessage), "üòµ File will not be displayed ",
+                                                    "File is not valid UTF-8 encoded, like a markdown file or text file."));
+      }
+    }
+  }
+  catch (const std::ios_base::failure& error)
+  {
+    std::cerr << "ERROR: Could not read file: " << finalRequestPath_ << ". Message: " << error.what() << ".\nError code: " << error.code()
+              << std::endl;
+    Glib::signal_idle().connect_once(
+        sigc::bind(sigc::mem_fun(mainWindow, &MainWindow::setMessage), "üéÇ Could not read file", "Message: " + std::string(error.what())));
+  }
+  catch (const std::runtime_error& error)
+  {
+    std::cerr << "ERROR: File request failed, file: " << finalRequestPath_ << ". Message: " << error.what() << std::endl;
+    Glib::signal_idle().connect_once(
+        sigc::bind(sigc::mem_fun(mainWindow, &MainWindow::setMessage), "üéÇ File not found", "Message: " + std::string(error.what())));
+  }
+}
+
+/**
+ * \brief Validate if text is valid UTF-8.
+ * \param text String that needs to be validated
+ * \return true if valid UTF-8
+ */
+bool Middleware::validateUTF8(const Glib::ustring& text) const
+{
+  return text.validate();
+}
+
+/**
+ * \brief Simple wrapper of the method below with void return
+ */
+void Middleware::doIPFSStatusUpdateOnce()
+{
+  doIPFSStatusUpdate();
+}
+
+/**
+ * \brief Timeout slot: Update the IPFS connection status every x seconds.
+ * Process requests inside a seperate thread, to avoid blocking the GUI thread.
+ * \return always true, when running as a GTK timeout handler
+ */
+bool Middleware::doIPFSStatusUpdate()
+{
+  // Stop any on-going status calls first, if applicable
+  abortStatus();
+
+  if (statusThread_ == nullptr)
+  {
+    statusThread_ = new std::thread(&Middleware::processIPFSStatus, this);
+  }
+  // Keep going (never disconnect the timer)
+  return true;
+}
+
+/**
+ * Process the IPFS status calls.
+ * Runs inside a thread.
+ */
+void Middleware::processIPFSStatus()
+{
+  std::lock_guard<std::mutex> guard(status_mutex_);
+  try
+  {
+    ipfsNumberOfPeers_ = ipfs_status_.getNrPeers();
+    if (ipfsNumberOfPeers_ > 0)
+    {
+      // Auto-refresh page if needed (when 'Please wait' page was shown)
+      if (waitPageVisible_)
+        Glib::signal_idle().connect_once(sigc::mem_fun(mainWindow, &MainWindow::refreshRequest));
+
+      std::map<std::string, std::variant<int, std::string>> repoStats = ipfs_status_.getRepoStats();
+      ipfsRepoSize_ = std::get<int>(repoStats.at("repo-size"));
+      ipfsRepoPath_ = std::get<std::string>(repoStats.at("path"));
+
+      std::map<std::string, float> rates = ipfs_status_.getBandwidthRates();
+      char buf[32];
+      ipfsIncomingRate_ = std::string(buf, std::snprintf(buf, sizeof buf, "%.1f", rates.at("in") / 1000.0));
+      ipfsOutcomingRate_ = std::string(buf, std::snprintf(buf, sizeof buf, "%.1f", rates.at("out") / 1000.0));
+    }
+    else
+    {
+      ipfsRepoSize_ = 0;
+      ipfsRepoPath_ = "";
+      ipfsIncomingRate_ = "0.0";
+      ipfsOutcomingRate_ = "0.0";
+    }
+
+    if (ipfsClientID_.empty())
+      ipfsClientID_ = ipfs_status_.getClientID();
+    if (ipfsClientPublicKey_.empty())
+      ipfsClientPublicKey_ = ipfs_status_.getClientPublicKey();
+    if (ipfsVersion_.empty())
+      ipfsVersion_ = ipfs_status_.getVersion();
+
+    // Trigger update of all status fields, in a thread-safe manner
+    Glib::signal_idle().connect_once(sigc::mem_fun(mainWindow, &MainWindow::updateStatusPopoverAndIcon));
+  }
+  catch (const std::runtime_error& error)
+  {
+    std::string errorMessage = std::string(error.what());
+    if (errorMessage != "Request was aborted")
+    {
+      // Assume no connection or connection lost; display disconnected
+      ipfsNumberOfPeers_ = 0;
+      ipfsRepoSize_ = 0;
+      ipfsRepoPath_ = "";
+      ipfsIncomingRate_ = "0.0";
+      ipfsOutcomingRate_ = "0.0";
+      Glib::signal_idle().connect_once(sigc::mem_fun(mainWindow, &MainWindow::updateStatusPopoverAndIcon));
+    }
+  }
+}
+
+/**
+ * Abort request call and stop the thread, if applicable.
+ */
+void Middleware::abortRequest()
+{
+  if (requestThread_ && requestThread_->joinable())
+  {
+    if (is_request_thread_done_)
+    {
+      requestThread_->join();
+    }
+    else
+    {
+      // Trigger the thread to stop now.
+      // We call the abort method of the IPFS client.
+      ipfs_fetch_.abort();
+      keep_request_thread_running_ = false;
+      requestThread_->join();
+      // Reset states, allowing new threads with new API requests/calls
+      ipfs_fetch_.reset();
+      keep_request_thread_running_ = true;
+    }
+    delete requestThread_;
+    requestThread_ = nullptr;
+    is_request_thread_done_ = false; // reset
+  }
+}
+
+/**
+ * Abort status calls and stop the thread, if applicable.
+ */
+void Middleware::abortStatus()
+{
+  if (statusThread_ && statusThread_->joinable())
+  {
+    if (is_status_thread_done_)
+    {
+      statusThread_->join();
+    }
+    else
+    {
+      // Trigger the thread to stop now.
+      // We call the abort method of the IPFS client.
+      ipfs_status_.abort();
+      statusThread_->join();
+      // Reset states, allowing new threads with new API status calls
+      ipfs_status_.reset();
+    }
+    delete statusThread_;
+    statusThread_ = nullptr;
+    is_status_thread_done_ = false; // reset
+  }
+}
diff --git a/src/middleware.h b/src/middleware.h
new file mode 100644
index 00000000..0267d038
--- /dev/null
+++ b/src/middleware.h
@@ -0,0 +1,93 @@
+#ifndef MIDDLEWARE_H
+#define MIDDLEWARE_H
+
+#include "ipfs.h"
+#include <atomic>
+#include <glibmm/dispatcher.h>
+#include <glibmm/ustring.h>
+#include <map>
+#include <mutex>
+#include <sigc++/connection.h>
+#include <string>
+#include <thread>
+#include <variant>
+
+/* Forward declarations */
+struct cmark_node;
+class MainWindow;
+
+/**
+ * \class Middleware
+ * \brief Handles (IPFS) network requests and File IO from disk towards the GUI
+ */
+class Middleware
+{
+public:
+  explicit Middleware(MainWindow& mainWindow, const std::string& timeout);
+  virtual ~Middleware();
+  void doRequest(const std::string& path = std::string(),
+                 bool isSetAddressBar = true,
+                 bool isHistoryRequest = false,
+                 bool isDisableEditor = true,
+                 bool isParseContent = true);
+  std::string doAdd(const std::string& path);
+  void doWrite(const std::string& path, bool isSetAddressAndTitle = true);
+  void setContent(const Glib::ustring& content);
+  Glib::ustring getContent() const;
+  cmark_node* parseContent() const;
+  void resetContentAndPath();
+  std::size_t getIPFSNumberOfPeers() const;
+  int getIPFSRepoSize() const;
+  std::string getIPFSRepoPath() const;
+  std::string getIPFSIncomingRate() const;
+  std::string getIPFSOutcomingRate() const;
+  std::string getIPFSVersion() const;
+  std::string getIPFSClientId() const;
+  std::string getIPFSClientPublicKey() const;
+
+private:
+  MainWindow& mainWindow;
+  Glib::Dispatcher requestStarted_;
+  Glib::Dispatcher requestFinished_;
+  sigc::connection statusTimerHandler_;
+  // Threading:
+  std::thread* requestThread_;                    /* Request thread pointer */
+  std::thread* statusThread_;                     /* Status thread pointer */
+  std::atomic<bool> is_request_thread_done_;      /* Indication when the single request (fetch) is done */
+  std::atomic<bool> keep_request_thread_running_; /* Trigger the request thread to stop/continue */
+  std::atomic<bool> is_status_thread_done_;       /* Indication when the status calls are done */
+
+  // IPFS:
+  std::string ipfsHost_;    /* IPFS host name */
+  int ipfsPort_;            /* IPFS port number */
+  std::string ipfsTimeout_; /* IPFS time-out setting */
+  IPFS ipfs_fetch_;         /* IPFS object for fetch calls */
+  IPFS ipfs_status_;        /* IPFS object for status calls, so it doesn't conflict with the fetch request */
+  std::size_t ipfsNumberOfPeers_;
+  int ipfsRepoSize_;
+  std::string ipfsRepoPath_;
+  std::string ipfsIncomingRate_;
+  std::string ipfsOutcomingRate_;
+  std::string ipfsVersion_;
+  std::string ipfsClientID_;
+  std::string ipfsClientPublicKey_;
+  std::mutex status_mutex_; /* IPFS status mutex to protect class members */
+
+  // Request & Response:
+  std::string requestPath_;
+  std::string finalRequestPath_;
+  Glib::ustring currentContent_;
+  bool waitPageVisible_;
+
+  void processRequest(const std::string& path, bool isParseContent);
+  void fetchFromIPFS(bool isParseContent);
+  void openFromDisk(bool isParseContent);
+  bool validateUTF8(const Glib::ustring& text) const;
+  void doIPFSStatusUpdateOnce();
+  bool doIPFSStatusUpdate();
+  void processIPFSStatus();
+  void abortRequest();
+  void abortStatus();
+};
+
+#endif
\ No newline at end of file
diff --git a/src/option-group.cc b/src/option-group.cc
new file mode 100644
index 00000000..e466cf29
--- /dev/null
+++ b/src/option-group.cc
@@ -0,0 +1,39 @@
+#include "option-group.h"
+
+OptionGroup::OptionGroup() : Glib::OptionGroup("main_group", "Options", "Options"), timeout("120s"), disableIPFSDaemon(false), version(false)
+{
+  Glib::OptionEntry entry1;
+  entry1.set_long_name("timeout");
+  entry1.set_short_name('t');
+  entry1.set_description("Change time-out value of IPFS fetch; TIMEOUT should be a string, like 5m (default: 120s)");
+  entry1.set_arg_description("TIMEOUT");
+  add_entry(entry1, timeout);
+
+  Glib::OptionEntry entry2;
+  entry2.set_long_name("disable-ipfs-daemon");
+  entry2.set_short_name('d');
+  entry2.set_description("Do NOT start IPFS daemon during browser start-up (normally you would want to have IPFS "
+                         "running, so this option is NOT advised)");
+  add_entry(entry2, disableIPFSDaemon);
+
+  Glib::OptionEntry entryVersion;
+  entryVersion.set_long_name("version");
+  entryVersion.set_short_name('v');
+  entryVersion.set_description("Show version");
+  add_entry(entryVersion, version);
+}
+
+bool OptionGroup::on_pre_parse(Glib::OptionContext& context, Glib::OptionGroup& group)
+{
+  return Glib::OptionGroup::on_pre_parse(context, group);
+}
+
+bool OptionGroup::on_post_parse(Glib::OptionContext& context, Glib::OptionGroup& group)
+{
+  return Glib::OptionGroup::on_post_parse(context, group);
+}
+
+void OptionGroup::on_error(Glib::OptionContext& context, Glib::OptionGroup& group)
+{
+  Glib::OptionGroup::on_error(context, group);
+}
\ No newline at end of file
diff --git a/src/option-group.h b/src/option-group.h
new file mode 100644
index 00000000..7a2630d8
--- /dev/null
+++ b/src/option-group.h
@@ -0,0 +1,27 @@
+#ifndef OPTION_GROUP_H
+#define OPTION_GROUP_H
+
+#include <glibmm/optioncontext.h>
+#include <glibmm/optionentry.h>
+#include <glibmm/optiongroup.h>
+
+/**
+ * \class OptionGroup
+ * \brief Command-line Parameters options class
+ */
+class OptionGroup : public Glib::OptionGroup
+{
+public:
+  OptionGroup();
+
+  // Implement virtuals methods
+  bool on_pre_parse(Glib::OptionContext& context, Glib::OptionGroup& group) override;
+  bool on_post_parse(Glib::OptionContext& context, Glib::OptionGroup& group) override;
+  void on_error(Glib::OptionContext& context, Glib::OptionGroup& group) override;
+
+  Glib::ustring timeout;
+  bool disableIPFSDaemon;
+  bool version;
+};
+
+#endif
\ No newline at end of file
diff --git a/src/project_config.h.in b/src/project_config.h.in
new file mode 100644
index 00000000..6f057424
--- /dev/null
+++ b/src/project_config.h.in
@@ -0,0 +1,12 @@
+#ifndef PROJECT_CONFIG_H
+#define PROJECT_CONFIG_H
+
+#define PROJECT_NAME "@PROJECT_NAME@"
+#define PROJECT_VER "@PROJECT_VERSION@"
+#define PROJECT_VER_MAJOR "@PROJECT_VERSION_MAJOR@"
+#define PROJECT_VER_MINOR "@PROJECT_VERSION_MINOR@"
+#define PROJECT_VER_PATCH "@PROJECT_VERSION_PATCH@"
+
+#define INSTALL_PREFIX "@CMAKE_INSTALL_PREFIX@"
+
+#endif // PROJECT_CONFIG_H
\ No newline at end of file
diff --git a/src/schema/org.gtk.Settings.ColorChooser.gschema.xml b/src/schema/org.gtk.Settings.ColorChooser.gschema.xml
new file mode 100644
index 00000000..6270d331
--- /dev/null
+++ b/src/schema/org.gtk.Settings.ColorChooser.gschema.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<schemalist>
+
+  <schema id='org.gtk.Settings.ColorChooser' path='/org/gtk/settings/color-chooser/'>
+    <key name='custom-colors' type='a(dddd)'>
+      <default>[]</default>
+      <summary>Custom colors</summary>
+      <description>
+        An array of custom colors to show in the color chooser. Each color is
+        specified as a tuple of four doubles, specifying RGBA values between
+        0 and 1.
+      </description>
+    </key>
+    <key name='selected-color' type='(bdddd)'>
+      <default>(false,1.0,1.0,1.0,1.0)</default>
+      <summary>The selected color</summary>
+      <description>
+         The selected color, described as a tuple whose first member is a
+         boolean that is true if a color was selected, and the remaining
+         four members are four doubles, specifying RGBA values between
+         0 and 1.
+      </description>
+    </key>
+  </schema>
+
+</schemalist>
diff --git a/src/schema/org.gtk.Settings.Debug.gschema.xml b/src/schema/org.gtk.Settings.Debug.gschema.xml
new file mode 100644
index 00000000..abb985dc
--- /dev/null
+++ b/src/schema/org.gtk.Settings.Debug.gschema.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<schemalist>
+
+  <schema id='org.gtk.Settings.Debug' path='/org/gtk/settings/debug/'>
+    <key name='enable-inspector-keybinding' type='b'>
+      <default>false</default>
+      <summary>Enable inspector keybinding</summary>
+      <description>
+        If this setting is true, GTK+ lets the user open an interactive
+        debugging window with a keybinding. The default shortcuts for
+        the keybinding are Control-Shift-I and Control-Shift-D.
+      </description>
+    </key>
+    <key name='inspector-warning' type='b'>
+      <default>true</default>
+      <summary>Inspector warning</summary>
+      <description>
+        If this setting is true, GTK+ shows a warning before letting
+        the user use the interactive debugger.
+      </description>
+    </key>
+  </schema>
+
+</schemalist>
+
diff --git a/src/schema/org.gtk.Settings.EmojiChooser.gschema.xml b/src/schema/org.gtk.Settings.EmojiChooser.gschema.xml
new file mode 100644
index 00000000..20e3db4f
--- /dev/null
+++ b/src/schema/org.gtk.Settings.EmojiChooser.gschema.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<schemalist>
+
+  <schema id='org.gtk.Settings.EmojiChooser' path='/org/gtk/settings/emoji-chooser/'>
+    <key name='recent-emoji' type='a((auss)u)'>
+      <default>[]</default>
+      <summary>Recently used Emoji</summary>
+      <description>
+        An array of Emoji definitions to show in the Emoji chooser. Each Emoji is
+        specified as an array of codepoints, name and shortname. The extra integer after this
+        pair is the code of the Fitzpatrick modifier to use in place of a 0 in the
+        codepoint array.
+      </description>
+    </key>
+  </schema>
+
+</schemalist>
diff --git a/src/schema/org.gtk.Settings.FileChooser.gschema.xml b/src/schema/org.gtk.Settings.FileChooser.gschema.xml
new file mode 100644
index 00000000..dda603ab
--- /dev/null
+++ b/src/schema/org.gtk.Settings.FileChooser.gschema.xml
@@ -0,0 +1,178 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright ¬© 2010 Christian Persch
+
+  This library is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published by
+  the Free Software Foundation; either version 2.1, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library. If not, see <http://www.gnu.org/licenses/>.
+-->
+<schemalist>
+
+  <enum id='org.gtk.Settings.FileChooser.LocationMode'>
+    <value nick='path-bar' value='0'/>
+    <value nick='filename-entry' value='1'/>
+  </enum>
+
+  <enum id='org.gtk.Settings.FileChooser.SortColumn'>
+    <value nick='name' value='0'/>
+    <value nick='size' value='1'/>
+    <value nick='type' value='2'/>
+    <value nick='modified' value='3'/>
+  </enum>
+
+  <enum id='org.gtk.Settings.FileChooser.SortOrder'>
+    <value nick='ascending' value='0'/>
+    <value nick='descending' value='1'/>
+  </enum>
+
+  <enum id='org.gtk.Settings.FileChooser.StartupMode'>
+    <value nick='recent' value='0'/>
+    <value nick='cwd' value='1'/>
+  </enum>
+
+  <enum id='org.gtk.Settings.FileChooser.ClockFormat'>
+    <value nick='24h' value='0'/>
+    <value nick='12h' value='1'/>
+  </enum>
+
+  <enum id='org.gtk.Settings.FileChooser.DateFormat'>
+    <value nick='regular' value='0'/>
+    <value nick='with-time' value='1'/>
+  </enum>
+
+  <enum id='org.gtk.Settings.FileChooser.TypeFormat'>
+    <value nick='mime' value='0'/>
+    <value nick='description' value='1'/>
+    <value nick='category' value='2'/>
+  </enum>
+
+  <schema id='org.gtk.Settings.FileChooser' path='/org/gtk/settings/file-chooser/'>
+    <key name='last-folder-uri' type='s'>
+      <default>""</default>
+    </key>
+    <key name='location-mode' enum='org.gtk.Settings.FileChooser.LocationMode'>
+      <default>'path-bar'</default>
+      <summary>Location mode</summary>
+      <description>
+	Controls whether the file chooser shows just a path bar, or a visible entry
+        for the filename as well, for the benefit of typing-oriented users. The
+        possible values for these modes are "path-bar" and "filename-entry".
+      </description>
+    </key>
+    <key name='show-hidden' type='b'>
+      <default>false</default>
+      <summary>Show hidden files</summary>
+      <description>
+	Controls whether the file chooser shows hidden files or not.
+      </description>
+    </key>
+    <key type="b" name="sort-directories-first">
+      <default>false</default>
+      <summary>Show folders first</summary>
+      <description>
+        If set to true, then folders are shown before files in the list.
+      </description>
+    </key>
+    <key name='expand-folders' type='b'>
+      <default>false</default>
+      <summary>Expand folders</summary>
+      <description>This key is deprecated; do not use it.</description>
+    </key>
+    <key name='show-size-column' type='b'>
+      <default>true</default>
+      <summary>Show file sizes</summary>
+      <description>
+	Controls whether the file chooser shows a column with file sizes.
+      </description>
+    </key>
+    <key name='show-type-column' type='b'>
+      <default>true</default>
+      <summary>Show file types</summary>
+      <description>
+	Controls whether the file chooser shows a column with file types.
+      </description>
+    </key>
+    <key name='sort-column' enum='org.gtk.Settings.FileChooser.SortColumn'>
+      <default>'name'</default>
+      <summary>Sort column</summary>
+      <description>
+	Can be one of "name", "modified", or "size".  It controls
+	which of the columns in the file chooser is used for sorting
+	the list of files.
+      </description>
+    </key>
+    <key name='sort-order' enum='org.gtk.Settings.FileChooser.SortOrder'>
+      <default>'ascending'</default>
+      <summary>Sort order</summary>
+      <description>
+	Can be one of the strings "ascending" or "descending".
+      </description>
+    </key>
+    <key name='window-position' type='(ii)'>
+      <default>(-1, -1)</default>
+      <summary>Window position</summary>
+      <description>
+	The (x, y) coordinates of the upper-left corner of the GtkFileChooserDialog's
+        window.
+      </description>
+    </key>
+    <key name='window-size' type='(ii)'>
+      <default>(-1, -1)</default>
+      <summary>Window size</summary>
+      <description>
+	The size (width, height) of the GtkFileChooserDialog's window, in pixels.
+      </description>
+    </key>
+    <key name='startup-mode' enum='org.gtk.Settings.FileChooser.StartupMode'>
+      <default>'recent'</default>
+      <summary>Startup mode</summary>
+      <description>
+	Either "recent" or "cwd"; controls whether the file chooser
+	starts up showing the list of recently-used files, or the
+	contents of the current working directory.
+      </description>
+    </key>
+    <key name='sidebar-width' type='i'>
+      <default>148</default>
+      <summary>Sidebar width</summary>
+      <description>
+	Width in pixels of the file chooser's places sidebar.
+      </description>
+    </key>
+    <key name="clock-format" enum="org.gtk.Settings.FileChooser.ClockFormat">
+      <default>'24h'</default>
+      <summary>Time format</summary>
+      <description>
+        Whether the time is shown in 24h or 12h format.
+      </description>
+    </key>
+    <key name="date-format" enum="org.gtk.Settings.FileChooser.DateFormat">
+      <default>'regular'</default>
+      <summary>Date format</summary>
+      <description>
+        The amount of detail to show in the Modified column.
+      </description>
+    </key>
+    <key name="type-format" enum="org.gtk.Settings.FileChooser.TypeFormat">
+      <default>'category'</default>
+      <summary>Type format</summary>
+      <description>
+        Different ways to show the 'Type' column information.
+        Example outputs for a video mp4 file:
+        'mime' -> 'video/mp4'
+        'description' -> 'MPEG-4 video'
+        'category' -> 'Video'
+      </description>
+    </key>
+  </schema>
+
+</schemalist>
diff --git a/src/schema/org.libreweb.browser.gschema.xml b/src/schema/org.libreweb.browser.gschema.xml
new file mode 100644
index 00000000..9610500e
--- /dev/null
+++ b/src/schema/org.libreweb.browser.gschema.xml
@@ -0,0 +1,61 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<schemalist>
+  <schema path="/org/libreweb/browser/" id="org.libreweb.browser">
+    <key name="width" type="i">
+      <default>1000</default>
+      <summary>Window width</summary>
+    </key>
+    <key name="height" type="i">
+      <default>800</default>
+      <summary>Window height</summary>
+    </key>
+    <key name="maximized" type="b">
+      <default>false</default>
+      <summary>Is window maximized</summary>
+    </key>
+    <key name="fullscreen" type="b">
+      <default>false</default>
+      <summary>Is window fullscreen</summary>
+    </key>
+    <key name="position-divider" type="i">
+      <default>42</default>
+      <summary>Position of paned divider</summary>
+    </key>
+    <key name="font-family" type="s">
+      <default>"Sans"</default>
+      <summary>Font family</summary>
+    </key>
+    <key name="font-size" type="i">
+      <default>10</default>
+      <summary>Font size</summary>
+    </key>
+    <key name="spacing" type="i">
+      <default>0</default>
+      <summary>Font spacing</summary>
+    </key>
+    <key name="margins" type="i">
+      <default>20</default>
+      <summary>Text margins</summary>
+    </key>
+    <key name="indent" type="i">
+      <default>0</default>
+      <summary>Text indent</summary>
+    </key>
+    <key name="icon-theme" type="s">
+      <default>"flat"</default>
+      <summary>Icon theme</summary>
+    </key>
+    <key name="icon-gtk-theme" type="b">
+      <default>false</default>
+      <summary>Is GTK default theme active</summary>
+    </key>
+    <key name="brightness" type="d">
+      <default>1.0</default>
+      <summary>Brightnesse</summary>
+    </key>
+    <key name="dark-theme" type="b">
+      <default>false</default>
+      <summary>Prefer dark theme</summary>
+    </key>
+  </schema>
+</schemalist>
diff --git a/src/source-code-dialog.cc b/src/source-code-dialog.cc
new file mode 100644
index 00000000..7c9c7360
--- /dev/null
+++ b/src/source-code-dialog.cc
@@ -0,0 +1,43 @@
+#include "source-code-dialog.h"
+#include <gtkmm/textbuffer.h>
+
+SourceCodeDialog::SourceCodeDialog() : accelGroup(Gtk::AccelGroup::create())
+{
+  set_title("View source code");
+  set_default_size(700, 750);
+  add_accel_group(accelGroup); // TODO: Impl. a menu?
+
+  m_closeButton.add_label("_Close", true);
+  m_closeButton.set_margin_top(10);
+  m_closeButton.signal_clicked().connect(sigc::mem_fun(this, &SourceCodeDialog::hide));
+  m_sourceCode.set_editable(false);
+  m_scrolledWindow.add(m_sourceCode);
+  m_scrolledWindow.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
+
+  auto vbox = get_content_area();
+  vbox->pack_start(m_scrolledWindow, true, true, 0);
+  vbox->pack_start(m_closeButton, false, false, 0);
+
+  show_all_children();
+}
+SourceCodeDialog::~SourceCodeDialog()
+{
+}
+
+/**
+ * \brief Set multi-line code source
+ * \param[in] text Source code text
+ */
+void SourceCodeDialog::setText(const std::string& text)
+{
+  Glib::RefPtr<Gtk::TextBuffer> buffer = m_sourceCode.get_buffer();
+  buffer->set_text(text);
+}
+
+/**
+ * \brief Hide the code source dialog
+ */
+void SourceCodeDialog::hide_dialog(__attribute__((unused)) int response)
+{
+  hide();
+}
\ No newline at end of file
diff --git a/src/source-code-dialog.h b/src/source-code-dialog.h
new file mode 100644
index 00000000..c1c95526
--- /dev/null
+++ b/src/source-code-dialog.h
@@ -0,0 +1,31 @@
+#ifndef SOURCE_CODE_WINDOW_H
+#define SOURCE_CODE_WINDOW_H
+
+#include <gtkmm/dialog.h>
+#include <gtkmm/scrolledwindow.h>
+#include <gtkmm/textview.h>
+#include <string>
+
+/**
+ * \class SourceCodeDialog
+ * \brief Source-code pop-up window
+ */
+class SourceCodeDialog : public Gtk::Dialog
+{
+public:
+  SourceCodeDialog();
+  virtual ~SourceCodeDialog();
+  void setText(const std::string& text);
+  void hide_dialog(int response);
+
+protected:
+  // Child widgets
+  Gtk::ScrolledWindow m_scrolledWindow;
+  Gtk::TextView m_sourceCode;
+  Gtk::Button m_closeButton;
+  Glib::RefPtr<Gtk::AccelGroup> accelGroup;
+
+private:
+};
+
+#endif
\ No newline at end of file
